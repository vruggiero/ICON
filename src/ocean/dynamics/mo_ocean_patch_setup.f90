! ICON
!
! ---------------------------------------------------------------
! Copyright (C) 2004-2024, DWD, MPI-M, DKRZ, KIT, ETH, MeteoSwiss
! Contact information: icon-model.org
!
! See AUTHORS.TXT for a list of authors
! See LICENSES/ for license information
! SPDX-License-Identifier: BSD-3-Clause
! ---------------------------------------------------------------

! The module <i>mo_model_import_domain</i>
! provides functionality to import information about the models computational
! domain. This information is read from several files that were generated by
! the patch_2D generator programm. The data types describing the model domain are
! contained in <i>mo_domain_model</i>.

!----------------------------
#include "omp_definitions.inc"
!----------------------------

MODULE mo_ocean_patch_setup
  !-------------------------------------------------------------------------
  USE mo_exception,          ONLY: finish, warning, message
  USE mo_model_domain,       ONLY: t_patch
  USE mo_parallel_config,    ONLY: nproma
  USE mo_grid_config,        ONLY: corio_lat, grid_angular_velocity, use_dummy_cell_closure, &
    & grid_sphere_radius, lplane
  USE mo_sync,               ONLY: sync_c, sync_e, sync_v, sync_patch_array, sync_idx
  USE mo_grid_subset,        ONLY: t_subset_range, get_index_range, read_subset, write_subset
  USE mo_mpi,                ONLY: work_mpi_barrier, get_my_mpi_work_id, my_process_is_mpi_seq, global_mpi_barrier, &
    & get_my_global_mpi_id

  USE mo_loopindices
  USE mo_impl_constants
  USE mo_math_types
  USE mo_math_utilities
!   USE mo_grid_geometry_info, ONLY: planar_torus_geometry
  USE mo_grid_tools,         ONLY: calculate_edge_area
  USE mo_model_domimp_setup, ONLY: init_coriolis
  USE mo_dynamics_config,    ONLY: lcoriolis, ldeepatmo
  USE mo_sync,               ONLY: disable_sync_checks, enable_sync_checks

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: complete_ocean_patch
  !-------------------------------------------------------------------------

CONTAINS

  !----------------------------------------------------------------------------
  !>
!<Optimize:inUse>
  SUBROUTINE complete_ocean_patch( patch_2D)
    TYPE(t_patch), TARGET, INTENT(inout) :: patch_2D

    CALL init_coriolis( lcoriolis, lplane, ldeepatmo, patch_2D )
    CALL complete_ocean_patch_geometry( patch_2D )

  END SUBROUTINE complete_ocean_patch
  !----------------------------------------------------------------------------


  !----------------------------------------------------------------------------
  !>
  !! Computes the local orientation of the edge primal normal and dual normal.
  !!
  !! Computes the local orientation of the edge primal normal and dual normal
  !! at the location of the cell centers and vertices.
  !! Moreover, the Cartesian orientation vectors of the edge primal normals
  !! are stored for use in the RBF initialization routines, and inverse
  !! primal and dual edge lengths are computed
  !!
  !! Note: Not clear if all the included calclulations are needed
  !!
  !!
!<Optimize:inUse>
  SUBROUTINE complete_ocean_patch_geometry( patch_2D)
    TYPE(t_patch), TARGET, INTENT(inout) :: patch_2D

    INTEGER :: jb, je!, jc
    INTEGER :: start_idx, end_idx
    TYPE(t_subset_range), POINTER :: all_edges, owned_edges

    INTEGER :: ilc1, ibc1, ilv1, ibv1, ilc2, ibc2, ilv2, ibv2, &
      & ilv3, ibv3, ilv4, ibv4!, ile1, ibe1

    REAL(wp) :: z_nu, z_nv, z_lon, z_lat, z_nx1(3), z_nx2(3), z_norm

    TYPE(t_cartesian_coordinates) :: cc_ev3, cc_ev4

    !-----------------------------------------------------------------------
    all_edges    => patch_2D%edges%ALL
    owned_edges  => patch_2D%edges%owned

    ! !$OMP PARALLEL  PRIVATE(rl_start,rl_end,i_startblk,i_endblk)
    !
    ! First step: compute Cartesian coordinates and Cartesian vectors on full domain
    ! this is needed to vectorize RBF initialization; the existing field carrying
    ! the Cartesian orientation vectors (primal_cart_normal) did not work for that
    ! because it is a derived data type
    ! In addition, the fields for the inverse primal and dual edge lengths are
    ! initialized here.
    !
    ! !$OMP DO PRIVATE(jb,start_idx,end_idx,je) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = all_edges%start_block, all_edges%end_block
      CALL get_index_range(all_edges, jb, start_idx, end_idx)
      DO je = start_idx, end_idx

        ! compute Cartesian coordinates (needed for RBF initialization)
        patch_2D%edges%inv_primal_edge_length(je,jb) = &
          & 1._wp/patch_2D%edges%primal_edge_length(je,jb)

        ! compute inverse dual edge length (undefined for refin_ctrl=1)
        patch_2D%edges%inv_dual_edge_length(je,jb) = &
          & 1._wp/patch_2D%edges%dual_edge_length(je,jb)

      ENDDO

    END DO !block loop
    ! !$OMP END DO

    ! Second step: computed projected orientation vectors and related information

    ! Initialization of lateral boundary points
    ! !$OMP WORKSHARE
    patch_2D%edges%vertex_idx(:,:,3)            = 0
    patch_2D%edges%vertex_blk(:,:,3)            = 0
    patch_2D%edges%vertex_idx(:,:,4)            = 0
    patch_2D%edges%vertex_blk(:,:,4)            = 0
   ! !$OMP END WORKSHARE
    !
    ! loop through all patch_2D edges
    !
    ! !$OMP DO PRIVATE(jb,start_idx,end_idx,je,ilc1,ibc1,ilv1,ibv1,ilc2,ibc2,ilv2, &
    ! !$OMP            ibv2,ilv3,ibv3,ilv4,ibv4,z_nu,z_nv,z_lon,z_lat,z_nx1,z_nx2,   &
    ! !$OMP            cc_ev3,cc_ev4,z_norm) ICON_OMP_DEFAULT_SCHEDULE
    DO jb = owned_edges%start_block, owned_edges%end_block
      CALL get_index_range(owned_edges, jb, start_idx, end_idx)
      DO je = start_idx, end_idx

        IF(.NOT.patch_2D%edges%decomp_info%owner_mask(je,jb)) CYCLE

        ! compute edge-vertex indices (and blocks) 3 and 4, which
        ! are the outer vertices of cells 1 and 2, respectively,
        ! and the inverse length bewtween vertices 3 and 4

        ilc1 = patch_2D%edges%cell_idx(je,jb,1)
        ibc1 = patch_2D%edges%cell_blk(je,jb,1)
        ilc2 = patch_2D%edges%cell_idx(je,jb,2)
        ibc2 = patch_2D%edges%cell_blk(je,jb,2)

        ilv1 = patch_2D%edges%vertex_idx(je,jb,1)
        ibv1 = patch_2D%edges%vertex_blk(je,jb,1)
        ilv2 = patch_2D%edges%vertex_idx(je,jb,2)
        ibv2 = patch_2D%edges%vertex_blk(je,jb,2)

        IF( ilc1 < 1 .or. ilc2 < 1) CYCLE
        IF( ilv1 < 1 .or. ilv2 < 1) &
          CALL finish("complete_ocean_patch_geometry","ilv1 < 1 .or. ilv2 < 1")

        IF ((patch_2D%cells%vertex_idx(ilc1,ibc1,1) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,1) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc1,ibc1,1) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,1) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,3) = patch_2D%cells%vertex_idx(ilc1,ibc1,1)
          patch_2D%edges%vertex_blk(je,jb,3) = patch_2D%cells%vertex_blk(ilc1,ibc1,1)

        ELSE IF ((patch_2D%cells%vertex_idx(ilc1,ibc1,2) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,2) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc1,ibc1,2) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,2) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,3) = patch_2D%cells%vertex_idx(ilc1,ibc1,2)
          patch_2D%edges%vertex_blk(je,jb,3) = patch_2D%cells%vertex_blk(ilc1,ibc1,2)

        ELSE IF ((patch_2D%cells%vertex_idx(ilc1,ibc1,3) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,3) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc1,ibc1,3) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc1,ibc1,3) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,3) = patch_2D%cells%vertex_idx(ilc1,ibc1,3)
          patch_2D%edges%vertex_blk(je,jb,3) = patch_2D%cells%vertex_blk(ilc1,ibc1,3)

        ENDIF

        IF ((patch_2D%cells%vertex_idx(ilc2,ibc2,1) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,1) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc2,ibc2,1) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,1) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,4) = patch_2D%cells%vertex_idx(ilc2,ibc2,1)
          patch_2D%edges%vertex_blk(je,jb,4) = patch_2D%cells%vertex_blk(ilc2,ibc2,1)

        ELSE IF ((patch_2D%cells%vertex_idx(ilc2,ibc2,2) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,2) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc2,ibc2,2) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,2) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,4) = patch_2D%cells%vertex_idx(ilc2,ibc2,2)
          patch_2D%edges%vertex_blk(je,jb,4) = patch_2D%cells%vertex_blk(ilc2,ibc2,2)

        ELSE IF ((patch_2D%cells%vertex_idx(ilc2,ibc2,3) /= &
          & patch_2D%edges%vertex_idx(je,jb,1) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,3) /= &
          & patch_2D%edges%vertex_blk(je,jb,1)) .AND.  &
          & (patch_2D%cells%vertex_idx(ilc2,ibc2,3) /= &
          & patch_2D%edges%vertex_idx(je,jb,2) .OR.  &
          & patch_2D%cells%vertex_blk(ilc2,ibc2,3) /= &
          & patch_2D%edges%vertex_blk(je,jb,2)) )        THEN

          patch_2D%edges%vertex_idx(je,jb,4) = patch_2D%cells%vertex_idx(ilc2,ibc2,3)
          patch_2D%edges%vertex_blk(je,jb,4) = patch_2D%cells%vertex_blk(ilc2,ibc2,3)

        ENDIF


      ENDDO

    END DO !block loop
    ! !$OMP END DO NOWAIT

    ! !$OMP END PARALLEL

    ! primal_normal_cell must be sync'd before next loop,
    ! so do a sync for all above calculated quantities

    CALL disable_sync_checks
    CALL sync_idx(sync_e,sync_v,patch_2D,patch_2D%edges%vertex_idx(:,:,3), &
      & patch_2D%edges%vertex_blk(:,:,3))
    CALL sync_idx(sync_e,sync_v,patch_2D,patch_2D%edges%vertex_idx(:,:,4), &
      & patch_2D%edges%vertex_blk(:,:,4))

    CALL enable_sync_checks


    !!$OMP PARALLEL  PRIVATE(rl_start,rl_end,i_startblk,i_endblk)
    !!$OMP END PARALLEL

    CALL calculate_edge_area(patch_2D)

  END SUBROUTINE complete_ocean_patch_geometry
  !-------------------------------------------------------------------------


END MODULE mo_ocean_patch_setup
