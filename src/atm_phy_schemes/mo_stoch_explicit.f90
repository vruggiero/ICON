! ICON
!
! ---------------------------------------------------------------
! Copyright (C) 2004-2024, DWD, MPI-M, DKRZ, KIT, ETH, MeteoSwiss
! Contact information: icon-model.org
!
! See AUTHORS.TXT for a list of authors
! See LICENSES/ for license information
! SPDX-License-Identifier: BSD-3-Clause
! ---------------------------------------------------------------

! Explicit stochastic shallow convection routine.
!
! Description:
! This routine is not a stand-alone convection parameterization, but is
! used in conjunction with a conventional mass flux parameterization
! scheme, currently the Tiedtke-Bechtold scheme. It replaces the cloud
! base mass flux calculated with the conventional scheme with a
! stochastically perturbed mass flux value for each grid cell.
! This perturbed mass flux is generated by constructing two mass flux
! distributions (Weibull) representative of the entire cloud ensemble
! (separately for active and passive shallow clouds), and then populating
! each grid cell with clouds randomly drawn from these distributions.
! The explicit version of the scheme keeps track of up to 5000 individual
! clouds in each grid cell, tracking their average (across lifetime) mass
! flux, lifetime, type (active/passive), cloud base height and updraft
! area fraction. The grid cell total mass flux is then determined by
! adding the mass flux of all individual clouds present within the grid cell.
! New clouds are generated with a Poisson process and assigned a
! (lifetime-average) mass flux drawn from two Weibull distributions
! representative of the entire shallow cloud ensemble
! Required input for the construction of the mass flux distributions are
! the "bulk" or first-guess mass flux calculated by the conventional
! convection scheme (applied to profiles averaged over a representative
! neighbourhood), surface fluxes, depth of the subcloud layer, moist
! static energy differential at cloud base between updraft and environment
! and various fixed parameters derived from LES.
!
! A full description of the scheme can be found in the following
! publications:
! Sakradzija et al. (2015) NPG
! Sakradzija et al. (2016) JAMES
! Sakradzija and Hohenegger (2017) JAS
! Sakradzija and Klocke (2018) JAMES
!
! Compile with FFLAG -fall-intrinsics
!
!-----------------------------------------------------------------------------

MODULE mo_stoch_explicit

  USE netcdf
#ifdef HAVE_ACM_LICENSE  
  USE random_rewrite,        ONLY: random_Poisson
#endif  
  USE mo_kind,               ONLY: JPRB=>wp ,JPIM=>i4
  USE mo_model_domain,       ONLY: t_patch
  USE mo_loopindices,        ONLY: get_indices_c
  USE mo_impl_constants_grf, ONLY: grf_bdywidth_c
  USE mo_impl_constants,     ONLY: min_rlcell_int
  USE mo_physical_constants, ONLY: alv, cpd
  USE mo_cuparameters,       ONLY: alpha_mf, beta_mf, m0, C1, kinv, active_fraction, &
                                   mavg1, k_wei, nclds
  USE cloud_random_numbers,  ONLY: rng_type, IRngMinstdVector, IRngNative
  USE mo_math_constants,     ONLY: rad2deg
  USE mo_gribout_config,     ONLY: gribout_config

  IMPLICIT NONE

  PUBLIC :: shallow_stoch_explicit

  CONTAINS


  ! Main subroutine call
  SUBROUTINE shallow_stoch_explicit(i_startidx,i_endidx,klon,klev,dt,pgeoh,mbas_con,mtop_con,mf_bulk, shfl,&
                              & lhfl, temp_s, mf_perturb, mfp, mfa, dh, ktype, extra_3d,core,deprof,lseed,cell_area,clnum,&
                              & ncloudspout,ncloudsaout,time_i, life_i, mf_i, type_i, ktype_i, area_i, depth_i, base_i, &
                              & used_cell,lpassive,lgrayzone,luse3d,lspinup,ncloudspin,ncloudsain)

    !Interface variables
  INTEGER(KIND=JPIM),INTENT(IN)    :: i_startidx           ! current block's index start
  INTEGER(KIND=JPIM),INTENT(IN)    :: i_endidx             ! current block's index end
  INTEGER(KIND=JPIM),INTENT(IN)    :: klon                 ! number of grid points in current block
  INTEGER(KIND=JPIM),INTENT(IN)    :: klev                 ! number of model layers
  INTEGER(KIND=JPIM),INTENT(IN)    :: mbas_con(klon)       ! model level index of cloud base (LCL) from test parcel ascent
  INTEGER(KIND=JPIM),INTENT(IN)    :: mtop_con(klon)       ! model level index of cloud top from test parcel ascent
  REAL(KIND=JPRB)   ,INTENT(IN)    :: dt                   ! length of physics time step (s)
  REAL(KIND=JPRB)   ,INTENT(IN)    :: pgeoh(klon,klev+1)   ! geopotential height (above ground level) on model layer interfaces
  REAL(KIND=JPRB)   ,INTENT(IN)    :: mf_bulk(klon)        ! bulk/first-guess mass flux derived from T-B scheme (normalised by grid cell area)
  REAL(KIND=JPRB)   ,INTENT(IN)    :: shfl(klon)           ! surface sensible heat flux
  REAL(KIND=JPRB)   ,INTENT(IN)    :: lhfl(klon)           ! surface latent heat flux
  REAL(KIND=JPRB)   ,INTENT(IN)    :: temp_s(klon)         ! temperature on lowest model level
  REAL(KIND=JPRB)   ,INTENT(OUT)   :: mf_perturb(klon)     ! stochastically perturbed mass flux, all clouds
  REAL(KIND=JPRB)   ,INTENT(OUT)   :: mfp(klon)            ! stochastically perturbed mass flux, passive clouds only
  REAL(KIND=JPRB)   ,INTENT(OUT)   :: mfa(klon)            ! stochastically perturbed mass flux, active clouds only
  REAL(KIND=JPRB)   ,INTENT(IN)    :: dh(klon)             ! moist static energy difference updraft/environment at cloud base
  INTEGER(KIND=JPIM),INTENT(IN)    :: ktype(klon)          ! convection type (0:off, 1:deep, 2:shallow, 3:mid-level)
  REAL(KIND=jprb)   ,INTENT(OUT)   :: clnum(klon)          ! number of clouds per grid cell (active+passive)
  REAL(KIND=JPRB)   ,INTENT(OUT)   :: core(klon,klev)      ! updraft core fraction profile derived from cloud ensemble in grid cell
  REAL(KIND=JPRB)   ,INTENT(OUT)   :: deprof(klon,klev)    ! detrainment profile derived from cloud ensemble in grid cell
  REAL(KIND=jprb)   ,INTENT(in)    :: cell_area(klon)      ! grid cell area
  INTEGER(KIND=JPIM),INTENT(in)    :: lseed(klon)          ! seed for random number generator
  REAL(KIND=jprb)   ,INTENT(OUT)   :: ncloudspout(klon)    ! number of passive clouds
  REAL(KIND=jprb)   ,INTENT(OUT)   :: ncloudsaout(klon)    ! number of active clouds

! individual cloud's properties for explicit stochastic
! cloud ensemble. Allocated to zero if not used.
  REAL(KIND=jprb)   ,INTENT(inout) :: time_i(:,:)          ! cloud's age
  REAL(KIND=jprb)   ,INTENT(inout) :: life_i(:,:)          ! cloud's expected lifetime
  REAL(KIND=jprb)   ,INTENT(inout) :: mf_i(:,:)            ! cloud base mass flux
  REAL(KIND=jprb)   ,INTENT(inout) :: type_i(:,:)          ! passive (1) or active (2)
  REAL(KIND=jprb)   ,INTENT(inout) :: ktype_i(:,:)         ! convection type shallow (2) or deep (1)
  REAL(KIND=jprb)   ,INTENT(inout) :: area_i(:,:)          ! cloud base updraft area
  INTEGER(KIND=JPIM),INTENT(inout) :: depth_i(:,:)         ! max depth of cloud (in model layers)
  INTEGER(KIND=JPIM),INTENT(inout) :: base_i(:,:)          ! cloud base (model layer)
  INTEGER(KIND=JPIM),INTENT(inout) :: used_cell(:,:)       ! mark whether cloud ensemble space is used
  LOGICAL           ,INTENT(IN)    :: lpassive             ! .true. if this routine is run passively (piggy-backing)
  LOGICAL           ,INTENT(IN)    :: luse3d               ! logical to switch on output of extra 3D diagnostics
  LOGICAL           ,INTENT(in)    :: lspinup              ! switches on cloud ensemble spinup
  ! This option enables instant spinup of the cloud ensemble
  ! into equilibrium with the large scale forcing (on average over many realisations, MF equals that of bulk MF).
  ! Normally, the cloud ensemble slowly develops over multiple time steps. For starts during actively convecting periods,
  ! instant spinup may be the preferred option.
  LOGICAL           ,INTENT(in)    :: lgrayzone            ! switches on grayzone tuning
  
  REAL(KIND=jprb)   ,INTENT(INOUT), DIMENSION(:,:,:), OPTIONAL :: extra_3d! 3D extra diagnostics
  !! only required when routine is run passively, in piggy-back-mode
  REAL(KIND=jprb)   ,INTENT(IN), OPTIONAL:: ncloudspin(klon) ! number of passive clouds at previous timestep
  REAL(KIND=jprb)   ,INTENT(IN), OPTIONAL:: ncloudsain(klon) ! number of active clouds at previous timestep

  ! Local variables
  REAL(KIND=JPRB) :: birth_rate_p(klon), birth_rate_a(klon)! birth rate passive/active clouds
  REAL(KIND=jprb) :: dxy                                   ! grid cell area
  REAL(KIND=jprb) :: bowen                                 ! Bowen ratio

  REAL(KIND=JPRB),    DIMENSION(klon) :: mavg2             ! expected mass flux of active cloud distribution
  REAL(KIND=JPRB),    DIMENSION(klon) :: lambda1           ! distribution parameter for passive Weibull distribution
  REAL(KIND=JPRB),    DIMENSION(klon) :: lambda2           ! distribution parameter for active Weibull distribution
  REAL(KIND=JPRB),    DIMENSION(klon) :: M                 ! total bulk mass flux in each cell (not normalised by grid cell area)
  REAL(KIND=JPRB),    DIMENSION(klon) :: hbas_con          ! convective cloud base height

  REAL(KIND=JPRB),    DIMENSION(klon) :: mf_new_a          ! increase of MF due to newly born active clouds
  REAL(KIND=JPRB),    DIMENSION(klon) :: mf_die_a          ! decrease of MF due to dying active clouds
  REAL(KIND=JPRB),    DIMENSION(klon) :: mf_new_p          ! increase of MF due to newly born passive clouds
  REAL(KIND=JPRB),    DIMENSION(klon) :: mf_die_p          ! decrease of MF due to dying passive clouds

  INTEGER(KIND=JPIM), DIMENSION(klon) :: nclouds           ! number of active+passive clouds in each grid cell
  INTEGER(KIND=JPIM), DIMENSION(klon) :: ncloudsa          ! number of active clouds in each grid cell
  INTEGER(KIND=JPIM), DIMENSION(klon) :: ncloudsp          ! number of passive clouds in each grid cell
  INTEGER(KIND=JPIM), DIMENSION(klon) :: nclouds_new_a     ! number of newly born active clouds
  INTEGER(KIND=JPIM), DIMENSION(klon) :: nclouds_die_a     ! number of dying active clouds
  INTEGER(KIND=JPIM), DIMENSION(klon) :: nclouds_new_p     ! number of newly born passive clouds
  INTEGER(KIND=JPIM), DIMENSION(klon) :: nclouds_die_p     ! number of dying passive clouds

  INTEGER :: i, j                                          ! (loop) indices

  ! distribution parameter for passive Weibull distribution is invariant, so calculate just once
  lambda1(:) = mavg1 / GAMMA(1.+kinv)


! Calculate situation-dependent lambda2 (active Weibull distribution parameter) based on heat-cycle
! arguments according to Sakradzija and Hohenegger 2017. Uses Bowen ratio, subcloud layer depth 
! and moist static energy difference between updraft and environment at cloud base
! Derive birth rates for passive/active clouds based on distribution parameters
!------------------------------------------------------------
  !! Loop over grid points
  DO i = i_startidx, i_endidx

    ! specify grid cell area
    dxy     = cell_area(i)

    ! Only consider grid cells with active shallow convection
    ! If the grayzone tuning is used (not recommended with stochastic scheme)
    ! ktype=1 (deep) will also be used.
    IF (ktype(i).EQ.2 .or. (lgrayzone .and. ktype(i).EQ.1)) THEN

      ! CALCULATION OF WEIBULL DISTRIBUTION PARAMETERS FOR ACTIVE/PASSIVE CLOUD POPULATIONS
      ! AND CALCULATION OF BIRTH RATES BASED ON Sakradzija and Hohenegger 2017
        
      ! bulk mass flux from first call to convection, convert into units of kg/s
      ! by multiplying with grid box area
      M(i)  = mf_bulk(i)*dxy ! bulk mass flux in kg/s; rho =1 kg/m3

      ! Calculate Bowen ratio. Make sure bowen cannot become zero!
      IF (shfl(i).GE.0._JPRB.OR.lhfl(i).GE.0._JPRB) THEN  
        Bowen = 0._JPRB
      ELSE
        Bowen = shfl(i)/lhfl(i)+1e-13_JPRB ! 1.e-13 added as safety against zero value
      END IF
      ! depth of subcloud layer, based on convective cloud base layer determined by test parcel ascent
      hbas_con(i) = pgeoh(i,mbas_con(i)) ! depth of subcloud layer

      ! Calculate distribution avgerage mass flux mavg2 for active clouds
      ! based on Eqn 12 Sakradzija and Hohenegger 2017
      mavg2(i)  = m0 + C1 * ( Bowen/(1+Bowen) + 0.608_JPRB*cpd*temp_s(i)/(alv+Bowen*alv) ) * &
                  hbas_con(i)*0.5_JPRB/(cpd*temp_s(i)) * & 
                  (-shfl(i)-lhfl(i))/dh(i)
      ! Check: use Bowen ratio to calculate mavg2 only if surface fluxes are into the atmosphere
      ! otherwise reduce expression for mavg2 to intercept parameter m0
      ! Rescaling is then necessary (since fixed parameters were derived for LES resolution)
      IF (shfl(i).GE.0._JPRB.OR.lhfl(i).GE.0._JPRB) THEN 
        mavg2(i)  = m0 * 51200._JPRB * 51200._JPRB
      ELSE
        mavg2(i)  = mavg2(i) * 51200._JPRB * 51200._JPRB
        mavg2(i)  = MAX(mavg2(i),10000._JPRB)
      ENDIF
        
      ! heat-cycle dependent Weibull parameter for active clouds
      lambda2(i)  = mavg2(i) / GAMMA(1.+kinv)

      ! Derive birth rates for passive/active clouds
      ! The "active_fraction" determines what fraction of the bulk MF will be represented by active vs. passive clouds
      ! Default: active_fraction=0.6, as a fixed parameter
      birth_rate_a(i) = active_fraction*M(i)/(alpha_mf*lambda2(i)**(beta_mf+1)* &
             &          gamma(1.+(beta_mf+1)*kinv))
      birth_rate_p(i) = (1._JPRB-active_fraction)*M(i)/(alpha_mf*lambda1(i)**(beta_mf+1)* &
             &          gamma(1.+(beta_mf+1)*kinv))
        
    ELSE
      ! if this grid point has no active shallow convection at this time step, no new clouds will be generated
      birth_rate_p(i) = 0._JPRB
      birth_rate_a(i) = 0._JPRB
    ENDIF 
  ENDDO

  ! Ensemble properties are calculated fresh at each time step, hence initialized to zero here
  mf_perturb       = 0.0_JPRB
  mfp              = 0.0_JPRB
  mfa              = 0.0_JPRB
  nclouds(:)       = 0.0_JPRB
  ncloudsa(:)      = 0.0_JPRB
  ncloudsp(:)      = 0.0_JPRB
  ncloudspout      = 0.0_JPRB
  ncloudsaout      = 0.0_JPRB
  nclouds_new_a(:) = 0
  nclouds_die_a(:) = 0
  mf_new_a(:)      = 0._JPRB
  mf_die_a(:)      = 0._JPRB
  nclouds_new_p(:) = 0
  nclouds_die_p(:) = 0
  mf_new_p(:)      = 0._JPRB
  mf_die_p(:)      = 0._JPRB
  core(:,:)        = 0._JPRB
  deprof(:,:)      = 0._JPRB

!------------------------------------------------------------
  ! Call routine that updates the state of the cloud ensemble by
  ! generating new clouds and removing clouds that have
  ! exceeded their lifetime, then calculates properties of the updated 
  ! cloud ensemble.

  ! Optional: set ftrace timer flag
  ! call ftrace_region_begin("update_cloud_ensemble")
  
  ! If routine is called in piggy-back-mode, it needs a few extra input variables
  ! in the interface to describe the state of the model at the previous timestep
  IF (lpassive) THEN 
    CALL update_cloud_ensemble(i_startidx,i_endidx, birth_rate_p, birth_rate_a, dt, klon, klev, &
       mbas_con,mtop_con,mavg1,mavg2, &
       nclouds,ncloudsp,ncloudsa, &
       nclouds_new_a, nclouds_die_a, mf_new_a, mf_die_a, &
       nclouds_new_p, nclouds_die_p, mf_new_p, mf_die_p, &
       lambda1, lambda2, alpha_mf, beta_mf, kinv, core,deprof, mf_perturb,mfp, mfa, ktype, &
       time_i, life_i, mf_i, type_i, ktype_i, area_i, depth_i, base_i, used_cell, &
       lseed,cell_area,lpassive,lgrayzone,lspinup,ncloudspin,ncloudsain)
  ELSE
  ! Call subroutine in active mode
    CALL update_cloud_ensemble(i_startidx,i_endidx, birth_rate_p, birth_rate_a, dt, klon, klev, &
       mbas_con,mtop_con,mavg1,mavg2, &
       nclouds,ncloudsp,ncloudsa, &
       nclouds_new_a, nclouds_die_a, mf_new_a, mf_die_a, &
       nclouds_new_p, nclouds_die_p, mf_new_p, mf_die_p, &
       lambda1, lambda2, alpha_mf, beta_mf, kinv, core,deprof, mf_perturb,mfp, mfa, ktype, &
       time_i, life_i, mf_i, type_i, ktype_i, area_i, depth_i, base_i, used_cell, &
       lseed,cell_area,lpassive,lgrayzone,lspinup)
  ENDIF
  ! Optional: set ftrace timer flag
  ! call ftrace_region_end("update_cloud_ensemble")

  ! Loop over grid points
  DO i = i_startidx, i_endidx
    ! Write ensemble state into diagnostic variables
    clnum(i)       = float(nclouds(i))  ! active+passive cloud numbers
    ncloudspout(i) = float(ncloudsp(i)) ! active coud numbers
    ncloudsaout(i) = float(ncloudsa(i)) ! passive cloud numbers

    ! Write extra diagnostics
    IF (luse3d) THEN
      extra_3d(i,1,1)=birth_rate_p(i)*dt      ! passive birth rate (in units of clouds per time step)
      extra_3d(i,2,1)=birth_rate_a(i)*dt      ! active birth rate (in units of clouds per time step)
      extra_3d(i,3,1)=float(ncloudsp(i))   ! current number of prognostic passive clouds (number)
      extra_3d(i,4,1)=float(ncloudsa(i))   ! current number of prognostic active clouds (number)
      extra_3d(i,5,1)=float(nclouds_new_p(i)) ! newborn passive clouds (number)
      extra_3d(i,6,1)=float(nclouds_die_p(i)) ! dying   passive clouds (number)
      extra_3d(i,7,1)=float(nclouds_new_a(i)) ! newborn active clouds (number)
      extra_3d(i,8,1)=float(nclouds_die_a(i)) ! dying   active clouds (number)
      extra_3d(i,9,1)=clnum(i)                ! total number of clouds (active+passive)
      extra_3d(i,10,1)=mf_perturb(i)          ! total mass flux (per unit area)
      extra_3d(i,11,1)=mfp(i)                 ! mass flux passive clouds
      extra_3d(i,12,1)=mfa(i)                 ! mass flux active clouds
      extra_3d(i,13,1)=mf_new_p(i)            ! MF of newborn passive clouds
      extra_3d(i,14,1)=mf_die_p(i)            ! MF of dying passive clouds
      extra_3d(i,15,1)=mf_new_a(i)            ! MF of newborn active clouds
      extra_3d(i,16,1)=mf_die_a(i)            ! MF of dying active clouds
      ! hypothetical death rates passive/active clouds as derived in SDE version, for comparison (in units of clouds per time step)
      extra_3d(i,17,1)=mfp(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(ncloudspout(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_jprb)
      extra_3d(i,18,1)=mfa(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(ncloudsaout(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_jprb)
    ENDIF
  ENDDO

 RETURN
 END SUBROUTINE shallow_stoch_explicit

!--------------------------------------------------------------------------------------
! Subroutine to update the state of the explicit cloud ensemble:
! generates new clouds, kills clouds that have 
! exceeded their lifetime, and calculates properties of the updated 
! cloud ensemble.

  SUBROUTINE update_cloud_ensemble(i_startidx,i_endidx, birth_rate_p, birth_rate_a, dt, klon, klev, &
                        mbas_con,mtop_con,mavg1,mavg2, &
                        nclouds,ncloudsp,ncloudsa, &
                        nclouds_new_a, nclouds_die_a, mf_new_a, mf_die_a, &
                        nclouds_new_p, nclouds_die_p, mf_new_p, mf_die_p, &
                        lambda1, lambda2, alpha_mf, beta_mf, kinv, core,deprof, mf_perturb, mfp, mfa, ktype, &
                        time_i, life_i, mf_i, type_i, ktype_i, area_i, depth_i, base_i, used_cell, &
                        lseed,cell_area,lpassive,lgrayzone,lspinup,ncloudspin,ncloudsain)

    IMPLICIT NONE

    ! Interface variables
    INTEGER(KIND=JPIM),INTENT(IN)    :: i_startidx          ! current block's index start
    INTEGER(KIND=JPIM),INTENT(IN)    :: i_endidx            ! current block's index end
    INTEGER(KIND=JPIM),INTENT(IN)    :: klon                ! number of grid points in current block
    INTEGER(KIND=JPIM),INTENT(IN)    :: klev                ! number of model levels
    REAL(KIND=JPRB)   ,INTENT(IN)    :: dt                  ! length of physics time step (s)
    INTEGER(KIND=JPIM),INTENT(IN)    :: mbas_con(klon)      ! model level index of cloud base (LCL) from test parcel ascent
    INTEGER(KIND=JPIM),INTENT(IN)    :: mtop_con(klon)      ! model level index of cloud top from test parcel ascent
    INTEGER(KIND=JPIM),INTENT(IN)    :: ktype(klon)         ! convection type (0:off, 1:deep, 2:shallow, 3:mid-level)
    REAL(KIND=JPRB),   INTENT(IN)    :: mavg1               ! expected value of mass flux distribution, passive clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: mavg2(klon)         ! expected value of mass flux distribution, active clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: lambda1(klon)       ! Weibull distribution parameter, passive clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: lambda2(klon)       ! Weibull distribution parameters, active clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: birth_rate_p(klon)       ! expected number of newborn passive clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: birth_rate_a(klon)       ! expected number of newborn active clouds
    REAL(KIND=JPRB),   INTENT(IN)    :: alpha_mf, beta_mf, kinv ! Weibull distribution parameters (invariant, derived from LES)
    REAL(KIND=JPRB),   INTENT(OUT)   :: core(klon,klev)     ! updraft core fraction profile derived from cloud ensemble in grid cell
    REAL(KIND=JPRB),   INTENT(OUT)   :: deprof(klon,klev)   ! detrainment profile derived from cloud ensemble in grid cell
    REAL(KIND=JPRB),   INTENT(INOUT) :: mf_perturb(klon)    ! stochastically perturbed mass flux, all clouds
    REAL(KIND=JPRB),   INTENT(INOUT) :: mfp(klon)           ! stochastically perturbed mass flux, passive clouds only
    REAL(KIND=JPRB),   INTENT(INOUT) :: mfa(klon)           ! stochastically perturbed mass flux, active clouds only
    REAL(KIND=JPRB),   INTENT(INOUT) :: mf_new_a(klon)      ! increase of MF due to newly born active clouds
    REAL(KIND=JPRB),   INTENT(INOUT) :: mf_die_a(klon)      ! decrease of MF due to dying active clouds
    REAL(KIND=JPRB),   INTENT(INOUT) :: mf_new_p(klon)      ! increase of MF due to newly born passive clouds
    REAL(KIND=JPRB),   INTENT(INOUT) :: mf_die_p(klon)      ! decrease of MF due to dying passive clouds
    
    INTEGER(KIND=JPIM),INTENT(INOUT) :: nclouds(klon)       ! number of active+passive clouds in each grid cell
    INTEGER(KIND=JPIM),INTENT(INOUT) :: ncloudsp(klon)      ! number of passive clouds in each grid cell
    INTEGER(KIND=JPIM),INTENT(INOUT) :: ncloudsa(klon)      ! number of active clouds in each grid cell
    INTEGER(KIND=JPIM),INTENT(INOUT) :: nclouds_new_a(klon) ! number of newly born active clouds
    INTEGER(KIND=JPIM),INTENT(INOUT) :: nclouds_die_a(klon) ! number of dying active clouds
    INTEGER(KIND=JPIM),INTENT(INOUT) :: nclouds_new_p(klon) ! number of newly born passive clouds
    INTEGER(KIND=JPIM),INTENT(INOUT) :: nclouds_die_p(klon) ! number of dying passive clouds

    ! individual cloud's properties for explicit stochastic
    ! cloud ensemble. Allocated to zero if not used.
    REAL(KIND=jprb)   ,INTENT(inout) :: time_i(:,:)          ! cloud's age
    REAL(KIND=jprb)   ,INTENT(inout) :: life_i(:,:)          ! cloud's expected lifetime
    REAL(KIND=jprb)   ,INTENT(inout) :: mf_i(:,:)            ! cloud base mass flux
    REAL(KIND=jprb)   ,INTENT(inout) :: type_i(:,:)          ! passive (1) or active (2)
    REAL(KIND=jprb)   ,INTENT(inout) :: ktype_i(:,:)         ! convection type shallow (2) or deep (1)
    REAL(KIND=jprb)   ,INTENT(inout) :: area_i(:,:)          ! cloud base updraft area
    INTEGER(KIND=JPIM),INTENT(inout) :: depth_i(:,:)         ! max depth of cloud (in model layers)
    INTEGER(KIND=JPIM),INTENT(inout) :: base_i(:,:)          ! cloud base (model layer)
    INTEGER(KIND=JPIM),INTENT(inout) :: used_cell(:,:)       ! mark whether cloud ensemble space is used    

    REAL(KIND=JPRB)   ,INTENT(IN)    :: cell_area(klon)     ! grid cell area
    INTEGER(KIND=JPIM),INTENT(IN)    :: lseed(klon)         ! seed for random number generator
    LOGICAL           ,INTENT(IN)    :: lpassive            ! .true. if this routine is run passively (piggy-backing)
    LOGICAL           ,INTENT(IN)    :: lgrayzone           ! switches on grayzone tuning
    LOGICAL           ,INTENT(IN)    :: lspinup             ! This option enables instant spinup of the cloud ensemble
    
    ! Only required when running in passive/piggy-backing mode
    REAL(KIND=JPRB)   ,INTENT(IN) ,OPTIONAL :: ncloudspin(klon) ! number of passive clouds at previous timestep
    REAL(KIND=JPRB)   ,INTENT(IN) ,OPTIONAL :: ncloudsain(klon) ! number of active clouds at previous timestep
    
    ! Local variables
    REAL(KIND=JPRB)    :: dxy                               ! grid cell area
    REAL(KIND=JPRB)    :: rdxy(klon)                        ! inverse of grid cell area
    
    REAL(KIND=JPRB)    :: ac, carea, cmf, xtime, xf         ! Parameters describing lifetime evolution of mass flux
    INTEGER(KIND=JPIM) :: i, j, k, icld,icld1,icldin,idx,ic1! Indices
    INTEGER(KIND=JPIM) :: current_depth                     ! cloud depth (model level), evolving with lifetime, at current stage in cloud's life time
    INTEGER(KIND=JPIM) :: n1, n2                            ! number of newborn cloud, from Poisson draw
    INTEGER(KIND=JPIM) :: nspin1, nspin2                    ! clouds that must be added to match current ensemble state (passive mode)
    INTEGER(KIND=JPIM) :: excessp,excessa                   ! clouds that must be removed to match current ensemble state (passive mode)

    REAL(KIND=JPRB)    :: rnd(nclds)                        ! sequence of random numbers generated by call to generator
    INTEGER(KIND=JPIM) :: iseed                             ! local copy of seed for random number generator
    INTEGER(KIND=JPIM) :: freecells                         ! number of free cells in cloud ensemble array
    INTEGER(KIND=JPIM) :: cntr1,cntr2                       ! counter
    INTEGER(KIND=JPIM) :: streammax                         ! length of random number sequence to be generated at once
    INTEGER(KIND=JPIM) :: spinup_steps                      ! number of time steps over which to spinup ensemble (if lspinup=.T.)
    INTEGER(KIND=JPIM) :: someclouds                        ! cloud counter
    INTEGER(KIND=JPIM) :: free_cell_list(nclds,klon)        ! index into cloud ensemble array, marking free cells
    INTEGER(KIND=JPIM) :: full_cell_list(nclds,klon)        ! index into cloud ensemble array, marking used cells
    INTEGER(KIND=JPIM),ALLOCATABLE ::n1array(:),n2array(:)  ! number of clouds to be generated at each spinup step (if lspinup=.T.)
    REAL(KIND=jprb)    :: z0  

    ! Type for random number generator and stream for producing random
    ! numbers
    TYPE(rng_type) :: random_number_generator

    REAL(KIND=JPRB), PARAMETER :: pi = 3.14159265358

    ! If spinup option is enabled, the ensemble will be iterated and updated over
    ! a suitable number of time steps to approach equilibrium. The number of
    ! time steps can be set here. Default is 3 hours.
    spinup_steps = 3*3600/dt ! equivalent to three hours

    ! Allocate arrays holding the number of clouds to be generated at each
    ! spinup time step
    IF (lspinup) THEN
       ALLOCATE(n1array(spinup_steps))
       ALLOCATE(n2array(spinup_steps))
    ENDIF 
!------------------------------------------------------------------------
!
!  
!    call ftrace_region_begin("domain_loop")

    ! Loop over grid points
    DO i = i_startidx, i_endidx

      ! Only consider grid cells with active shallow convection
      ! If the grayzone tuning is used (not recommended with stochastic scheme)
      ! ktype=1 (deep) will also be used.
      IF (ktype(i).EQ.2 .or. (lgrayzone .and. ktype(i).EQ.1)) THEN
        ! Review current state of the cloud ensemble:  
        ! Generate lists of free/used cells in cloud ensemble
        cntr1=0
        cntr2=0
        ! Loop over 5000 spaces in cloud ensemble array
        DO icld=1,nclds
          IF (used_cell(icld,i).eq.1) THEN
            cntr1=cntr1+1
            full_cell_list(cntr1,i)=icld
            IF (type_i(icld,i) .eq. 1) THEN
               ncloudsp(i)=ncloudsp(i)+1
            ENDIF
            IF (type_i(icld,i) .eq. 2) THEN
               ncloudsa(i)=ncloudsa(i)+1
            ENDIF
            nclouds(i)=nclouds(i)+1
          ELSE
            cntr2=cntr2+1
            free_cell_list(cntr2,i)=icld
          ENDIF
        ENDDO

        !  Get local copy of seed for random number generator        
        iseed = lseed(i)

        ! Initialise
        core(i,:)     = 0.0_JPRB ! Updraft core fraction profile
        deprof(i,:)   = 0.0_JPRB ! detrainment profile
        mf_perturb(i) = 0.0_JPRB ! stochastically perturbed mass flux active+passive
        mfp(i)        = 0.0_JPRB ! stochastically perturbed mass flux passive
        mfa(i)        = 0.0_JPRB ! stochastically perturbed mass flux active

        ! specify grid cell area
        dxy     = cell_area(i)
       

        !**************************************************************************************
        ! *PASSIVE MODE ONLY*  MATCH CURRENT STATE OF THE CLOUD ENSEMBLE PREDICTED BY SDE
        !
        ! If this routine is run passively, in piggy-back-mode, the state of the ensemble
        ! must first be nudged towards the model state at the previous time step.
        ! The following IF-loop only adjusts the number of clouds in the ensemble to 
        ! match that of the previous time step (i.e. killing or newly generating clouds 
        ! as needed), but does not explicitly nudge/adjust the ensemble total mass flux.
        ! Thus a discrepancy with the mass flux at the previous timestep does remain.
        IF (lpassive) THEN
          ! check for mismatch in cloud numbers of model state from SDE, vs. explicit cloud ensemble
          IF (ncloudsp(i) .LT. NINT(ncloudspin(i)*dxy) .OR.ncloudsa(i) .LT. NINT(ncloudsain(i)*dxy) ) THEN
            ! determine missing number of clouds to match required number of clouds
            nspin1=MAX(NINT(ncloudspin(i)*dxy)-ncloudsp(i),0)
            nspin2=MAX(NINT(ncloudsain(i)*dxy)-ncloudsa(i),0)
               
            ! Double check that new clouds to be generated don't exceed free spaces
            ! in cloud ensemble. This is theoretically possible as the SDE does not have
            ! a fixed upper limit for the clouds it may generate.
            freecells=cntr2
            ! If required, reduce cloud numbers to be newly generated to fit into empty spaces
            IF (nspin1+nspin2 .GT. freecells) THEN
              nspin1=MIN(MAX(nspin1-INT((nspin1+nspin2-freecells)/2._JPRB),0),freecells)
              nspin2=MIN(MAX(nspin2-INT((nspin1+nspin2-freecells)),0),freecells)
            ENDIF

            ! Random numbers required
            streammax=nspin1+nspin2+1
            !Initialize random number generator
            CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
                 &                                  nmaxstreams=streammax)
            ! Request streammax fresh random numbers to use in generation of new clouds
            CALL random_number_generator%uniform_distribution(rnd(1:streammax))

            ! Loop over number of passive clouds to be generated
            DO k=1,nspin1
              ! Increase counters for all and passive clouds
              nclouds(i)  = nclouds(i) + 1
              ncloudsp(i) = ncloudsp(i) + 1
              ! Pick a free cell index in the cloud ensemble array
              icldin=free_cell_list(k,i)
              ! Generate a new cloud
              CALL newClouds(i,lambda1(i),alpha_mf,beta_mf,kinv,1,ktype(i),icldin,mavg1, &
                   &            mbas_con(i),mtop_con(i),rnd(k),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))
            ENDDO
            ! Loop over number of active clouds to be generated
            DO k=nspin1+1,nspin1+nspin2
              ! Increase counters for all and active clouds
              nclouds(i) = nclouds(i) + 1
              ncloudsa(i) = ncloudsa(i) + 1
              ! Pick a free cell index in the cloud ensemble array
              icldin=free_cell_list(k,i)
              ! Generate a new cloud
              CALL newClouds(i,lambda2(i),alpha_mf,beta_mf,kinv,2,ktype(i),icldin,mavg2(i), &
                &            mbas_con(i),mtop_con(i),rnd(k),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))
            ENDDO
          ENDIF

          ! If number of clouds in ensemble is higher than the cloud state predicted by
          ! the SDE, remove excess clouds.
          ! Calculate excess number of clouds
          excessp=ncloudsp(i)-nint(ncloudspin(i)*dxy)
          excessa=ncloudsa(i)-nint(ncloudsain(i)*dxy)

          ! Update the list of free/used cells after adjustments,
          ! but this time counting only passive clouds!!!
          cntr1=0
          cntr2=0
          DO icld=1,nclds
            IF ((used_cell(icld,i).eq.1) .and. (type_i(icld,i) .eq. 1)) THEN
              cntr1=cntr1+1
              full_cell_list(cntr1,i)=icld
            ELSE
              cntr2=cntr2+1
              free_cell_list(cntr2,i)=icld
            ENDIF
          ENDDO
          IF (excessp .gt. 0) THEN
            ! Loop over number of excess passive clouds
            DO icld1=1,excessp
              ! Find index of each cloud by looking it up in full_cell_list
              icld=full_cell_list(icld1,i)
              ! Set cell properties back to default/zero for this cell  
              used_cell(icld,i)=0_JPIM
              type_i(icld,i)=0._JPRB
              ktype_i(icld,i)=0._JPRB
              mf_i(icld,i)=0._JPRB
              area_i(icld,i)=0._JPRB
              base_i(icld,i)=999_JPIM
              depth_i(icld,i)=0_JPIM
              ! Decrease number of all and passive clouds by one
              nclouds(i) = nclouds(i) - 1
              ncloudsp(i) = ncloudsp(i) - 1
            ENDDO
          ENDIF

          ! Update the list of free/used cells after adjustments,
          ! but this time counting only active clouds!!!
          cntr1=0
          cntr2=0
          DO icld=1,nclds
            IF ((used_cell(icld,i).eq.1) .and. (type_i(icld,i) .eq. 2)) THEN
              cntr1=cntr1+1
              full_cell_list(cntr1,i)=icld
            ELSE
              cntr2=cntr2+1
              free_cell_list(cntr2,i)=icld
            ENDIF
          ENDDO
          IF (excessa .gt. 0) THEN
            ! Loop over number of excess active clouds
            DO icld1=1,excessa
              ! Find index of each cloud by looking it up in full_cell_list
              icld =full_cell_list(icld1,i)
              used_cell(icld,i)=0_JPIM
              type_i(icld,i)=0._JPRB
              ktype_i(icld,i)=0._JPRB
              mf_i(icld,i)=0._JPRB
              area_i(icld,i)=0._JPRB
              base_i(icld,i)=999_JPIM
              depth_i(icld,i)=0_JPIM
              ! Decrease number of all and active clouds by one
              nclouds(i) = nclouds(i) - 1
              ncloudsa(i) = ncloudsa(i) - 1
            ENDDO
          ENDIF
         
          ! Update the list of free/used cells after adjustments
          cntr1=0
          cntr2=0
          DO icld=1,nclds
            IF (used_cell(icld,i).eq.1) THEN
              cntr1=cntr1+1
              full_cell_list(cntr1,i)=icld
            ELSE
              cntr2=cntr2+1
              free_cell_list(cntr2,i)=icld
            ENDIF
          ENDDO

          ! Check that ensemble adjustment was successful
          IF (cntr1 .ne. nint(ncloudspin(i)*dxy)+nint(ncloudsain(i)*dxy)) THEN
             write(6,*) 'Adjustment of explicit cloud ensemble in passive mode was not successful!'
             write(6,*) 'Ensemble should contain clouds: ',nint(ncloudspin(i)*dxy)+nint(ncloudsain(i)*dxy)
             write(6,*) 'but actually contains clouds  : ',cntr1
          ENDIF
             
        ENDIF!lpassive

        !**************************************************************************************
        ! END *PASSIVE MODE ONLY*
        !**************************************************************************************
       
        ! Determine number of newborn clouds by drawing from a Poisson distribution with 
        ! "expected value" corresponding to the birth rates calculated above.
        streammax=200
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
             &                                  nmaxstreams=streammax)
        ! Request streammax new random numbers to use in Poisson distribution draws 
        CALL random_number_generator%uniform_distribution(rnd(1:streammax))

#ifdef HAVE_ACM_LICENSE
        ! Determine number of newborn passive clouds by drawing from Poisson distribution with given birth rate.
        idx=1! This index keeps track of which random numbers out of the 200 have already been used
        n1 = random_Poisson(birth_rate_p(i)*dt,idx,streammax,rnd(1:streammax))
        ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
        IF (idx .gt. streammax) THEN
           write(6,*) 'idx in first explicit Poisson draw out of range',idx,birth_rate_p(i)*dt, &
                & rnd(1),rnd(idx),MINVAL(rnd(1:streammax)),MAXVAL(rnd(1:streammax))
        ENDIF
        
        ! Determine number of newborn active clouds by drawing from Poisson distribution with given birth rate.
        idx=50! Start at index 50, to make sure to use "fresh" random numbers
        n2 = random_Poisson(birth_rate_a(i)*dt,idx,streammax,rnd(1:streammax))
        ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
        IF (idx .gt. streammax) THEN
           write(6,*) 'idx in 2nd explicit Poisson draw out of range',idx,birth_rate_a(i)*dt, &
                & rnd(1),rnd(idx),MINVAL(rnd(1:streammax)),MAXVAL(rnd(1:streammax))
        ENDIF
#else
        ! Determine number of newborn passive clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given birth rate.
        idx=1 ! This index keeps track of which random numbers out of the 200 have already been used
        z0 = SQRT(-2._JPRB * LOG(rnd(idx))) * COS(pi * rnd(idx+25))
        n1 = MAX(0, INT(z0 * SQRT(birth_rate_p(i)*dt) + birth_rate_p(i)*dt))
        
        ! Determine number of newborn active clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given birth rate.
        idx=50 ! This index keeps track of which random numbers out of the 200 have already been used
        z0 = SQRT(-2._JPRB * LOG(rnd(idx))) * COS(pi * rnd(idx+25))
        n2 = MAX(0, INT(z0 * SQRT(birth_rate_a(i)*dt) + birth_rate_a(i)*dt))
#endif
       
        ! Count clouds to be born. For small, non-zero birth rates, the Poisson draw
        ! my nevertheless return zero clouds to be born.
        someclouds=n1+n2

        ! SPINUP
        ! If the spinup option is enabled and we're on the first convection timestep, and
        ! any new clouds are to be generated, proceed...
        IF (lspinup .and. nclouds(i) .eq. 0) THEN
          idx=75 ! Start at index 75, to make sure to use "fresh" random numbers
          ! Iterate over number of spinup steps
          DO k=1,spinup_steps
#ifdef HAVE_ACM_LICENSE             
            n1 = random_Poisson(birth_rate_p(i)*dt,idx,streammax,rnd(1:streammax))
            ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
            IF (idx .gt. streammax) THEN
               write(6,*) 'idx in first explicit spinup Poisson draw out of range, at iteration ',k, &
                    & idx,birth_rate_p(i)*dt,rnd(1),rnd(idx),MINVAL(rnd(1:streammax)),MAXVAL(rnd(1:streammax))
            ENDIF
            n2 = random_Poisson(birth_rate_a(i)*dt,idx,streammax,rnd(1:streammax))
            ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
            IF (idx .gt. streammax) THEN
               write(6,*) 'idx in second explicit spinup Poisson draw out of range, at iteration ',k, &
                    & idx,birth_rate_p(i)*dt,rnd(1),rnd(idx),MINVAL(rnd(1:streammax)),MAXVAL(rnd(1:streammax))
            ENDIF
#else
            ! Determine number of newborn passive clouds by sampling a normal distribution
            ! (instead of Poisson) using the Box-Muller method, with given birth rate.
            z0 = SQRT(-2._JPRB * LOG(rnd(idx))) * COS(pi * rnd(idx+1))
            n1 = MAX(0, INT(z0 * SQRT(birth_rate_p(i)*dt) + birth_rate_p(i)*dt))
            
            ! Determine number of newborn active clouds by sampling a normal distribution
            ! (instead of Poisson) using the Box-Muller method, with given birth rate.
            z0 = SQRT(-2._JPRB * LOG(rnd(idx+2))) * COS(pi * rnd(idx+3))
            n2 = MAX(0, INT(z0 * SQRT(birth_rate_a(i)*dt) + birth_rate_a(i)*dt))
            idx=idx+4
#endif
            ! Save numbers of passive/active clouds to be born for each spinup time step in two arrays
            n1array(k)=n1
            n2array(k)=n2
          ENDDO
          ! Check total number of clouds to be generated
          someclouds=sum(n1array)+sum(n2array)
        ENDIF
       
        idx=200   ! Set random number index counter to 200, so that the first 200 numbers will not be used again  
      ELSE !ktype .ne. 2
         ! No new clouds are born if this grid cell has active no shallow convection
         n1 = 0
         n2 = 0
         someclouds=0
      ENDIF

      !*************************************************************************************
      ! END DETERMINATION OF CLOUD NUMBERS TO BE NEWLY BORN
      !-------------------------------------------------------------------------------------
      ! BEGIN GENERATING NEW CLOUDS
      !*************************************************************************************
      
      ! Add new clouds to the ensemble book-keeping
      ! Check that clouds to be born exist, and that there is space free in the array
      IF ((someclouds .gt. 0) .AND. ANY(used_cell(:,i).eq.0)) THEN
        ! Safety: New clouds to be generated must not exceed free spaces.
        ! If the number of free spaces in the ensemble is less than the number
        ! or new clouds to be generated, the number of new clouds will be reduced
        ! until it fits the remaining free spaces.
        freecells=cntr2
        IF (n1+n2 .GT. freecells) THEN
           n1=MIN(MAX(n1-INT((n1+n2-freecells)/2._JPRB),0),freecells)
           n2=MIN(MAX(n2-INT((n1+n2-freecells)),0),freecells)
        ENDIF
        
        ! If spinup is enabled...
        IF (lspinup .and. nclouds(i) .eq. 0) THEN

          ! Generate random numbers for clouds to be generated over all spinup steps, +200 used for prior Poisson draw
          streammax=sum(n1array)+sum(n2array)+idx
          CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
                 &                                  nmaxstreams=streammax)
          ! Retrieve streammax fresh random numbers to use in generation of new clouds
          CALL random_number_generator%uniform_distribution(rnd(1:streammax))

          ! Keep track of random number index used, so that random numbers are never used twice
          ! Use same index to pick free slots in the (still empty at start) cloud ensemble
          nspin2=idx+1 
          ! Iterate over spinup steps
          DO nspin1=1,spinup_steps

            ! Loop over each newly born passive cloud
            DO k=1,n1array(nspin1)    
              ! Since the cloud ensembe is still empty at the beginning of spinup,
              ! simpy pick subsequent free indices from the free_cell list.
              icldin=free_cell_list(nspin2-idx,i)
              ! Generate a new cloud
              CALL newClouds(i,lambda1(i),alpha_mf,beta_mf,kinv,1,ktype(i),icldin,mavg1, &
                  &             mbas_con(i),mtop_con(i),rnd(nspin2),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))
              nspin2=nspin2+1 
            ENDDO

            ! Loop over each newly born active cloud
            DO k=1,n2array(nspin1)     
              ! Since the cloud ensembe is still empty at the beginning of spinup,
              ! simpy pick subsequent free indices from the free_cell list.
              icldin=free_cell_list(nspin2-idx,i)
              ! Generate a new cloud
              CALL newClouds(i,lambda2(i),alpha_mf,beta_mf,kinv,2,ktype(i),icldin,mavg2(i), &
                &            mbas_con(i),mtop_con(i),rnd(nspin2),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))
              nspin2=nspin2+1
            ENDDO

            ! Throw out clouds that have died already, and adjust cloud numbers
            DO icld = 1, nclds
              ! Advance cloud life time since generation by one phyics time step
              IF (used_cell(icld,i).eq.1) time_i(icld,i) = time_i(icld,i) + dt
              ! Check if cloud has exceeded its assigned life time 
              IF ((used_cell(icld,i).eq.1).AND.(time_i(icld,i).GT.life_i(icld,i))) THEN 
                ! If so, reset current slot to default
                used_cell(icld,i)=0_JPIM
                time_i(icld,i)    = 0._JPRB
                life_i(icld,i)    = 0._JPRB
                area_i(icld,i)    = 0._JPRB
                depth_i(icld,i)   = 0_JPIM
                base_i(icld,i)    = 999_JPIM
                mf_i(icld,i)      = 0._JPRB
                type_i(icld,i)    = 0._JPRB
              ENDIF
            ENDDO

          ENDDO !nspin1, iterate over spinup time steps

          ! Initialise cloud counters
          nclouds(i)=0
          ncloudsa(i)=0
          ncloudsp(i)=0

          ! Review current state of the cloud ensemble:  
          ! Generate lists of free/used cells in cloud ensemble 
          cntr1=0
          cntr2=0
          DO icld = 1, nclds
            IF (used_cell(icld,i).eq.1) THEN
              cntr1=cntr1+1
              full_cell_list(cntr1,i)=icld
              IF (type_i(icld,i) .eq. 1) THEN
                ncloudsp(i)=ncloudsp(i)+1
              ELSE
                ncloudsa(i)=ncloudsa(i)+1
              ENDIF
              nclouds(i)=nclouds(i)+1
            ELSE
              cntr2=cntr2+1
              free_cell_list(cntr2,i)=icld
            ENDIF
          ENDDO

        ELSE
          ! NO SPINUP
          ! If no spinup is performed, merely initalise the random number generator,
          ! and generate sufficient random numbers for clouds to be born
          streammax=n1+n2+idx
          CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
               &                                  nmaxstreams=streammax)
          ! Retrieve nclds fresh random numbers to use in generation of new clouds
          CALL random_number_generator%uniform_distribution(rnd(1:streammax))
            
        ENDIF

        ! Generate new passive clouds
        DO k=1,n1     
          ! add passive cloud to all-cloud and passive counters
          nclouds(i) = nclouds(i) + 1
          ncloudsp(i) = ncloudsp(i) + 1
          ! finde a free slot in the inventory, and generate new cloud
          icldin=free_cell_list(k,i)
          CALL newClouds(i,lambda1(i),alpha_mf,beta_mf,kinv,1,ktype(i),icldin,mavg1, &
             &             mbas_con(i),mtop_con(i),rnd(k+idx),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))

          ! The following is for diagnostic purposes only!
          ! Calculate this new cloud's mass flux at the current time step,
          ! applying a simple function to describe the mass flux evolution
          ! over the cloud's lifetime (Sakradzija et al 2015 Eqn 32),
          ! in order to keep track of mass flux added by newborn clouds at this grid cell
          IF (life_i(icldin,i).GT.dt) THEN
            ! dimensionless time: time cloud will have lived at the end of the time step,
            ! divided by expected lifetime
            xtime = MIN((time_i(icldin,i)+dt) / life_i(icldin,i),1.0_JPRB)
            ! normalized life cycle
            xf    = ABS(4*xtime*(xtime-1._JPRB))
            ac    = 1._JPRB
            ! mass flux of the cloud at the end of the current time step
            cmf   = 3._JPRB/2._JPRB*xf**ac* mf_i(icldin,i)
          ELSE
            ! If cloud's expected lifetime is shorter than one timestep then the
            ! mass flux at the end of the time step is equal to the lifetime-average
            ! mass flux.
            cmf   = mf_i(icldin,i)
          ENDIF
          ! Count this newborn cloud's contribution to the grid box's passive mass flux
          ! If done correctly, this should be the mass flux at this first time step, cmf.
          ! mf_new_p(i)  = mf_new_p(i)  + cmf
          ! However, the diagnostics are used to compare to the SDE scheme, which does not
          ! model the time evolution of the mass flux, but assumes the cloud posesses
          ! the same constant, life-time average mass flux throughout its lifetime.
          ! To have a comparable mass flux diagnostic, pretend that newly born (and dying)
          ! clouds have the lifetime-average mass flux.
          mf_new_p(i)  = mf_new_p(i)  + mf_i(icldin,i)
        ENDDO

        ! Generate new active clouds
        DO k=1,n2     
          ! add active cloud to all-cloud and active counters 
          nclouds(i) = nclouds(i) + 1 !
          ncloudsa(i) = ncloudsa(i) + 1
          ! finde a free slot in the inventory, and generate new cloud
          icldin=free_cell_list(k+n1,i)
          CALL newClouds(i,lambda2(i),alpha_mf,beta_mf,kinv,2,ktype(i),icldin,mavg2(i), &
              &            mbas_con(i),mtop_con(i),rnd(k+n1+idx),mf_i(icldin,i),life_i(icldin,i),&
                   &            area_i(icldin,i),depth_i(icldin,i),time_i(icldin,i),type_i(icldin,i),&
                   &            ktype_i(icldin,i),base_i(icldin,i),used_cell(icldin,i))

          ! The following is for diagnostic purposes only!
          ! Calculate this new cloud's mass flux at the current time step,
          ! applying a simple function to describe the mass flux evolution
          ! over the cloud's lifetime (Sakradzija et al 2015 Eqn 32),
          ! in order to keep track of mass flux added by newborn clouds at this grid cell
          IF (life_i(icldin,i).GT.dt) THEN
            ! dimensionless time: time cloud will have lived at the end of the time step,
            ! divided by expected lifetime
            xtime = MIN((time_i(icldin,i)+dt) / life_i(icldin,i),1.0_JPRB)
            ! normalized life cycle 
            xf    = ABS(4*xtime*(xtime-1._JPRB))
            ac    = 1._JPRB
            ! mass flux of the cloud at the end of the current time step
            cmf   = 3._JPRB/2._JPRB*xf**ac* mf_i(icldin,i)
          ELSE
            cmf   = mf_i(icldin,i)
          ENDIF
          ! Count this newborn cloud's contribution to the grid box's active mass flux
          ! If done correctly, this should be the mass flux at this first time step, cmf.
          ! mf_new_a(i)  = mf_new_a(i)  + cmf
          ! However, the diagnostics are used to compare to the SDE scheme, which does not
          ! model the time evolution of the mass flux, but assumes the cloud posesses
          ! the same constant, life-time average mass flux throughout its lifetime.
          ! To have a comparable mass flux diagnostic, pretend that newly born (and dying)
          ! clouds have the lifetime-average mass flux.
          mf_new_a(i)  = mf_new_a(i)  + mf_i(icldin,i)
        ENDDO
        ! Keep track of number of newborn clouds at this time step
        nclouds_new_p(i)=n1
        nclouds_new_a(i)=n2

      ENDIF ! n>0

      !************************************************************************************
      ! END GENERATING NEW CLOUDS
      !************************************************************************************
     
      ! specify grid area
      rdxy(i)=1._JPRB/cell_area(i) !NOTE: this is the inverse of the gridbox area  

      ! Review current state of the cloud ensemble:  
      ! Generate lists of free/used cells in cloud ensemble 
      cntr1=0
      cntr2=0
      DO icld=1,nclds
        IF (used_cell(icld,i).eq.1) THEN
          cntr1=cntr1+1
          full_cell_list(cntr1,i)=icld
        ELSE
          cntr2=cntr2+1
          free_cell_list(cntr2,i)=icld
        ENDIF
      ENDDO

      !**************************************************************************************
      ! START INVENTORY OF CLOUD ENSEMBLE, AND CALCULATE GRID BOX MASS FLUX AND CLOUD NUMBERS
      !**************************************************************************************
      
!$NEC ivdep

      ! Loop over all occupied places (clouds) in the ensemble
      DO icld1 = 1, cntr1
        ! Find correct index to access slot in the ensemble 
        icld=full_cell_list(icld1,i)


        ! Update/lift convection base to level currently predicted by T-B test parcel, to
        ! follow BL evolution.
        ! Only do this if cloud was generated by shallow convection. Since the cloud top
        ! is kept track of as base+depth, for deep  convection the cloud top might shift
        ! above the model top without correction (adjusting depth also).
        IF (mbas_con(i) .NE.-1 .AND. (ktype(i).EQ.2 .or. (lgrayzone .and. ktype(i).EQ.1))) THEN 
           IF (ktype_i(icld,i) .eq. 2) then
            ! pick the higher model level out of the old and new base (model level)
            base_i(icld,i)=MIN(mbas_con(i),base_i(icld,i))
          ENDIF
        ENDIF

        ! Advance time that cloud has been alive by the slow physics time step dt
        time_i(icld,i) = time_i(icld,i) + dt
        ! Check if cloud has now lived longer than its assigned lifetime
        ! NOTE: Results are sensitive to the choice of whether the beginning/middle/end
        !       of the time step are being considered. 

        ! This is equivalent to not considering newborn clouds at all yet in the current
        ! time step, but only one full time step later. This is most equivalent to the
        ! assumption in the SDE scheme, which calculated its cloud death rate based solely
        ! on the number and mass flux of the cloud ensemble at the previous time step, and
        ! does not consider newly born clouds.
        IF (time_i(icld,i).GT.life_i(icld,i) + dt) THEN

        ! Here, clouds with lifetimes shorter than half a time step are immediately removed
        ! from the cloud ensemble and never counted for the grid box mass flux.
        ! IF (time_i(icld,i) + dt .GT.life_i(icld,i) + dt/2._JPRB) THEN

        ! Here, all clouds with lifetimes shorter than one time step are immediately
        ! removed from the cloud ensemble and never counted for the grid box mean mass flux.
        ! IF (time_i(icld,i) .GT.life_i(icld,i)) THEN

          ! If cloud has exceeded its lifetime, kill it but keep
          ! track of number and mass flux of dying cloud
          nclouds(i) = nclouds(i) - 1
          ! We don't really care about the dying cloud's properties
          ! anymore as they don't contribute to the grid box totals,
          ! except for diagnostic purposes.
          !
          ! For diagnostics only:
          ! By definition, MF at time of death is zero, so to determine 
          ! the MF of the dying cloud, we really have to calculate the
          ! MF of this cloud at the previous time step.
          ! This is done by calculating the normalised time from the previous time step
          xtime = (time_i(icld,i)-dt)/life_i(icld,i)
          !          *
          !      *       *
          !    *            *
          !  *                *
          !-*------------------*-
          !xf=0    xf=.5      xf=1
          xf    = ABS(4*xtime*(xtime-1._JPRB)) ! normalized life cycle
          ac    = 1._JPRB
          IF (life_i(icld,i).GT.dt) THEN
            ! Cloud base mass flux evolution follows a simple prescribed
            ! functional form (Sakradzija et al 2015 Eqn 32), increasing
            ! over the first half of the lifetime, and decaying over the second half
            cmf   = 3._JPRB/2._JPRB*xf**ac* mf_i(icld,i)
          ELSE
            ! If cloud's expected lifetime is shorter than one timestep
            ! its current mass flux is the lifetime average mass flux,
            ! cloud base level and cloud depth are as defined at the time
            ! of cloud creation. 
            cmf   = mf_i(icld,i)
          ENDIF
          ! Update diagnostics for passive clouds
          IF (type_i(icld,i).EQ.1) THEN
            ! Number of passive clouds remaining
            ncloudsp(i) = ncloudsp(i) - 1
            ! Number of passive clouds that have died during this time step
            nclouds_die_p(i)=nclouds_die_p(i)+1
            ! Mass flux lost through passive clouds dying during this time step
            ! If done correctly, this should be the mass flux at this first time step, cmf.
            ! mf_die_p(i)= mf_die_p(i) + cmf
            ! However, the diagnostics are used to compare to the SDE scheme, which does not
            ! model the time evolution of the mass flux, but assumes the cloud posesses
            ! the same constant, life-time average mass flux throughout its lifetime.
            ! To have a comparable mass flux diagnostic, pretend that newly born (and dying)
            ! clouds have the lifetime-average mass flux.
            mf_die_p(i)= mf_die_p(i) + mf_i(icld,i)
          ENDIF
          ! Update diagnostics for active clouds
          IF( type_i(icld,i).EQ.2) THEN
            ! Number of active clouds remaining
            ncloudsa(i) = ncloudsa(i) - 1
            ! Number of active clouds that have died during this time step
            nclouds_die_a(i)=nclouds_die_a(i)+1
            ! Mass flux lost through active clouds dying during this time step
            ! If done correctly, this should be the mass flux at this first time step, cmf.
            ! mf_die_a(i)= mf_die_a(i) + cmf
            ! However, the diagnostics are used to compare to the SDE scheme, which does not
            ! model the time evolution of the mass flux, but assumes the cloud posesses
            ! the same constant, life-time average mass flux throughout its lifetime.
            ! To have a comparable mass flux diagnostic, pretend that newly born (and dying)
            ! clouds have the lifetime-average mass flux.
            mf_die_a(i)= mf_die_a(i) + mf_i(icld,i)
          ENDIF
          ! reset values for newly emptied ensemble slots
          used_cell(icld,i) = 0_JPIM !
          type_i(icld,i)=0._JPRB
          ktype_i(icld,i)=0._JPRB
          mf_i(icld,i)=0._JPRB
          area_i(icld,i)=0._JPRB
          base_i(icld,i)=999_JPIM
          depth_i(icld,i)=0_JPIM
        ELSE ! if cloud remains alive...
          ! Calculate the cloud's mass flux and updraft area fraction at the current time step
          ! xtime is a dimensionless time normalised by the cloud's expected life time 
          xtime =MIN( time_i(icld,i) / life_i(icld,i),1._JPRB)
          ! We assume an idealized life cycle, the exponent ac is a tuning factor, here set to 1.
          !          *
          !      *       *
          !    *            *
          !  *                *
          !-*------------------*-
          !xf=0    xf=.5      xf=1
          xf    = ABS(4*xtime*(xtime-1._JPRB))
          ac    = 1._JPRB
          IF (life_i(icld,i).GT.dt) THEN
            ! Calculate current mass flux and updraft area fraction from
            ! lifetime average values
            carea = 3._JPRB/2._JPRB*xf**ac* area_i(icld,i)
            cmf   = 3._JPRB/2._JPRB*xf**ac* mf_i(icld,i)
          ELSE
            ! If cloud's expected lifetime is shorter than one timestep
            ! its current mass flux is the lifetime average mass flux,
            cmf   = mf_i(icld,i)
            ! Same for the updraft area fraction
            carea = area_i(icld,i)
          ENDIF

          ! Now calculate cloud depth according to life stage.
          ! We assume here that the cloud depth grows following
          ! a similar assumed shape as the mass flux for the first
          ! half of the cloud's lifetime (reaching its max depth at half)
          ! but remains at maximum for the second half of the cloud's
          ! life.
          !          * * * * * | max cloud depth
          !      *             |
          !    *               |
          !  *                 |
          !-*------------------|-
          !xf=0    xf=.5      xf=1
          ! If cloud lives longer than one time step...
          IF (life_i(icld,i).GT.dt) then
            ! ...and is in the first half of its lifetime
            IF (xtime.LT.0.5_JPRB ) THEN
              ! Calculate depth according to life stage
              current_depth = NINT(xf**ac*depth_i(icld,i),KIND=JPIM)
            ELSE
              ! In second half of the cloud's lifetime, depth=max depth  
              current_depth = depth_i(icld,i)
              ! Only during the second half of its lifetime is the
              ! cloud assumed to detrain, and detrain all its current
              ! mass flux at the cloud's maximum depth
              deprof(i,base_i(icld,i)-depth_i(icld,i))=cmf
            ENDIF
          ELSE
            ! If the cloud lives only one time step, its depth and base
            ! are those at time of creation
            current_depth = depth_i(icld,i)
          ENDIF
          ! Update grid box updraft area fraction by adding the cloud's
          ! (vertically invariant) updraft area fraction to the levels
          ! between the just defined cloud base and cloud top
          do j = base_i(icld,i)-current_depth, base_i(icld,i)
            core(i,j) = core(i,j)+carea
          end do

          ! Update the grid box total mass flux...
          ! ... from all clouds
          mf_perturb(i)  = mf_perturb(i)  + cmf
          ! ... from passive clouds only
          IF (type_i(icld,i).EQ.1) THEN
            mfp(i)  = mfp(i)  + cmf
          ENDIF
          ! ... from active clouds only
          IF (type_i(icld,i).EQ.2) THEN
            mfa(i)  = mfa(i)  + cmf
          ENDIF
           
        ENDIF ! if cloud still alive
      ENDDO ! Loop over individual clouds

      ! Normalise output fields by grid box area
      core(i,:)     = core(i,:)*rdxy(i)
      deprof(i,:)   = deprof(i,:)*rdxy(i)
      mf_perturb(i) = mf_perturb(i)*rdxy(i)
      mfp(i)        = mfp(i)*rdxy(i)
      mfa(i)        = mfa(i)*rdxy(i)
      mf_new_p(i)   = mf_new_p(i)*rdxy(i)
      mf_new_a(i)   = mf_new_a(i)*rdxy(i)
      mf_die_a(i)   = mf_die_a(i)*rdxy(i)
      mf_die_p(i)   = mf_die_p(i)*rdxy(i)
    ENDDO ! Loop over grid points

  RETURN
  END SUBROUTINE update_cloud_ensemble

!***********************************************************************************
! INVENTORY OF SIMPLE FUNCTIONS USED IN THE GENERATION OF NEW CLOUDS
!***********************************************************************************

  ! Calculates the maximum cloud depth of the updraft, based on the T-B max
  ! plume depth and the cloud's mass flux value relative to the bulk MF value.
  ! The assumption is that a cloud with larger mass flux has larger updraft area,
  ! and will grow deeper.
  FUNCTION cloud_depth(mf,mavg,mbascon,mtopcon) RESULT(mdep_con)
    ! parameterization of cloud depth as a function of mass flux
    
    REAL(KIND=JPRB)    mf, mavg
    INTEGER(KIND=JPIM) mbascon, mtopcon, mdep_con

    ! The convection top identified in the T-B test parcel ascent is assumed
    ! to mark the maximum extent of the strongest updrafts within the cloud
    ! ensemble. We further assume that a mass flux equal
    ! to the bulk T-B mass flux would lead to a maximum cloud depth that is
    ! 1/3 of the plume depth. Linear scaling, with cloud depth maximum limited
    ! to plume depth. Clouds must be at least one model layer thick.
    !
    !|-\ -------- plume top = max depth of cloud with strongest mass flux
    !|  \
    !|   \
    !|....\   ... cloud with "average" MF equal to bulk MF reach 1/3 of the max plume depth
    !|     \
    !|------\ --- plume base = cloud base
    !
    mdep_con=MAX(1,MIN(NINT((mbascon-mtopcon)*.3_JPRB*(mf/mavg)),mbascon-mtopcon))
  END FUNCTION cloud_depth

!---------------------------------------------------------------------------------------------  
  
  ! Calculates the cloud base updraft fraction within the current grid cell by
  ! converting mass flux to updraft area with the simple assumption of a constant updraft
  ! updraft velocity of 1.2m/s, and a constant density of 1kg/kg
  FUNCTION cloud_area(mf) RESULT(area)
    ! parameterization of cloud area as a function of mass flux
    
    REAL(KIND=JPRB) area,mf
    REAL(KIND=JPRB) w, rho

    w    = 1.2_JPRB   ! assumed constant updraft velocity of 1.2m/s
    rho  = 1._JPRB    ! assumed constant density
    area = mf/(rho*w) ! updraft area at cloud base
    
  END FUNCTION cloud_area

!---------------------------------------------------------------------------------------------
  
  ! Assigns lifetime to newly born clouds based on their lifetime-average 
  ! mass flux. Applied to both active and passive clouds.
  FUNCTION cloud_life_sample(mf,alpha_mf,beta_mf) RESULT(life)
    ! Parameterization of cloud lifetime as a function of mass flux
    ! see Sakradzija et al. 2015, Fig. 3 and text
    
    ! Input
    REAL(KIND=JPRB) mf         ! cloud's lifetime-average mass flux
    REAL(KIND=JPRB) beta_mf    ! parameter of the lifetime relationship
    REAL(KIND=JPRB) alpha_mf   ! parameter of the lifetime relationship
    ! Output
    REAL(KIND=JPRB) life       ! cloud's expected lifetime

    life = alpha_mf*mf**beta_mf

  END FUNCTION cloud_life_sample

!---------------------------------------------------------------------------------------------
  
  ! Assigns lifetime-average mass flux to newborn clouds
  FUNCTION cloud_mass_flux_sample(P,lambda,kinv) RESULT(mf)
    ! Draw a sample from the cloud ensemble's mass flux (Weibull) distribution
    ! Uses the inverse cumulative PDF P(mf) to draw a sample of cloud mass flux
    ! see Sakradzija and Klocke 2018, Eqn 3

    ! Input is a random number P, and the parameters of the assumed PDF
    REAL(KIND=JPRB) P            ! random number ]0,1[
    REAL(KIND=JPRB) lambda       ! Weibull distribution parameter
    REAL(KIND=JPRB) kinv         ! Weibull distribution parameter
    ! Output
    REAL(KIND=JPRB) mf           ! cloud's lifetime-average mass flux
    
    !single mode! draw from the inverse of cumulative PDF
    mf = lambda * (-LOG(1-P))**(kinv)  !Weibull
       
  END FUNCTION cloud_mass_flux_sample

!---------------------------------------------------------------------------------------------
  
  ! Creates a new cloud entry in the cloud ensemble at grid cell (i)
  SUBROUTINE newClouds(i,lambda,alpha_mf,beta_mf,kinv,isactive,ktype,icldin, &
       &                  mavg,mbascon,mtopcon,rnd, &
       &                  mf_i,life_i,area_i,depth_i,time_i,type_i,ktype_i,base_i,used_cell)
    
    INTEGER(KIND=JPIM), INTENT(IN)    :: i                                     ! grid cell index, current block index
    INTEGER(KIND=JPIM), INTENT(IN)    :: isactive                                 ! 1: passive, 2: active cloud
    INTEGER(KIND=JPIM), INTENT(IN)    :: icldin                                   ! index in nclds large cloud ensemble to be used
    REAL(KIND=JPRB)   , INTENT(IN)    :: lambda,alpha_mf,beta_mf,kinv,mavg        !distribution parameters
    INTEGER(KIND=JPIM), INTENT(IN)    :: mbascon,mtopcon                          ! model level index of cloud base and top from cumastrn
    REAL(KIND=JPRB)   , INTENT(IN)    :: rnd                                      ! random number ]0,1[ passed into routine
    INTEGER(KIND=JPIM), INTENT(IN)    :: ktype                                    ! Convection type 1: deep; 2: shallow
    REAL(KIND=JPRB)   , INTENT(INOUT) :: mf_i
    REAL(KIND=JPRB)   , INTENT(INOUT) :: life_i
    REAL(KIND=JPRB)   , INTENT(INOUT) :: area_i
    REAL(KIND=JPRB)   , INTENT(INOUT) :: time_i
    REAL(KIND=JPRB)   , INTENT(INOUT) :: type_i
    REAL(KIND=JPRB)   , INTENT(INOUT) :: ktype_i
    INTEGER(KIND=JPIM), INTENT(INOUT) :: base_i
    INTEGER(KIND=JPIM), INTENT(INOUT) :: depth_i
    INTEGER(KIND=JPIM) , INTENT(INOUT) :: used_cell
    INTEGER(KIND=JPIM) icld

    icld=icldin
    mf_i      = cloud_mass_flux_sample(rnd,lambda,kinv)  !cloud's massflux averaged over lifetime
    life_i    = cloud_life_sample(mf_i,alpha_mf,beta_mf) !cloud's expected lifetime
    area_i    = cloud_area(mf_i)                         !cloud's updraft area (at cloud base)
    depth_i   = cloud_depth(mf_i,mavg,mbascon,mtopcon)   !cloud's maximum depth (as model level)
    base_i    = mbascon                                  !cloud's cloud base (model) level at time of generation
    time_i    = 0._JPRB                                  ! Age of cloud at point of generation is zero
    used_cell = 1_JPIM                                   ! This slot in the ensemble is now taken
    type_i    = float(isactive)                          ! Keep track of whether this is an active or passive cloud
    ktype_i   = ktype                                    ! Keep track of whether this cloud is shallow or deep

  END SUBROUTINE newClouds

!---------------------------------------------------------------------------------------

 END MODULE mo_stoch_explicit
