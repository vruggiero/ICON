! ICON
!
! ---------------------------------------------------------------
! Copyright (C) 2004-2024, DWD, MPI-M, DKRZ, KIT, ETH, MeteoSwiss
! Contact information: icon-model.org
!
! See AUTHORS.TXT for a list of authors
! See LICENSES/ for license information
! SPDX-License-Identifier: BSD-3-Clause
! ---------------------------------------------------------------

! Stochastic differential equation (SDE) shallow convection subroutine.
!
! Description:
! This routine is not a stand-alone convection parameterization, but is
! used in conjunction with a conventional mass flux parameterization
! scheme, currently the Tiedtke-Bechtold scheme. It replaces the cloud
! base mass flux calculated with the conventional scheme with a
! stochastically perturbed mass flux value for each grid cell.
! This perturbed mass flux is generated by constructing two mass flux
! distributions (Weibull) representative of the entire cloud ensemble
! (separately for active and passive shallow clouds), and then populating
! each grid cell with clouds randomly drawn from these distributions.
! The SDE version of the scheme evolves four prognostic variables
! describing the state of the cloud ensemble (grid box mass flux and cloud
! numbers for active and passive cloud populations).
! Required input for the construction of the mass flux distributions are
! the "bulk" or first-guess mass flux calculated by the conventional
! convection scheme (applied to profiles averaged over a representative
! neighbourhood), surface fluxes, depth of the subcloud layer, moist
! static energy differential at cloud base between updraft and environment
! and various fixed parameters derived from LES.
!
! A full description of the scheme can be found in the following
! publications:
! Sakradzija et al. (2015) NPG
! Sakradzija et al. (2016) JAMES
! Sakradzija and Hohenegger (2017) JAS
! Sakradzija and Klocke (2018) JAMES
! Machulskaya and Seifert (2019) JAMES
!
! Compile with FFLAG -fall-intrinsics
!
!-----------------------------------------------------------------------------

MODULE mo_stoch_sde

  USE netcdf
#ifdef HAVE_ACM_LICENSE  
  USE random_rewrite,        ONLY: random_Poisson
#endif
  USE mo_kind,               ONLY: wp, i4
  USE mo_physical_constants, ONLY: alv, cpd
  USE mo_cuparameters,       ONLY: k_wei, alpha_mf, beta_mf, m0, C1, kinv, active_fraction, &
                                   mavg1
  USE cloud_random_numbers,  ONLY: rng_type, IRngMinstdVector, IRngNative

  IMPLICIT NONE

  PUBLIC :: shallow_stoch_sde, shallow_stoch_sde_passive

  CONTAINS


  !! Main subroutine calculating mass flux (MF) distribution, birth and death rates, determining
  !! the number of newborn/dying clouds, assigning each cloud a mass flux and incrementing the
  !! prognostic variables for grid box mass flux and cloud numbers.  
  !! This routine is called when the SDE scheme is run interactively. A second version of the 
  !! routine follows below for running passively (in piggy-backing mode) for comparison with the
  !! explicit stochastic scheme.  
  SUBROUTINE shallow_stoch_sde(i_startidx,i_endidx,klon,klev,ptsphy,pgeoh,mbas_con,&
                           & mfb, shfl, lhfl, temp_s, mfp, dh, ktype,clnum, &       
                           & pclnum_a, pclmf_a, &
                           & pclnum_p, pclmf_p, &
                           & lseed,extra_3d,luse3d,cell_area,lspinup,lgrayzone)

  !! Interface variables
  INTEGER(i4),INTENT(IN)    :: i_startidx         ! block index start            
  INTEGER(i4),INTENT(IN)    :: i_endidx           ! block index end
  INTEGER(i4),INTENT(IN)    :: klon               ! number of grid points in block
  INTEGER(i4),INTENT(IN)    :: klev               ! number of model layers
  INTEGER(i4),INTENT(IN)    :: mbas_con(klon)     ! model level index of cloud base (LCL)
  REAL(wp)   ,INTENT(IN)    :: ptsphy             ! length of physics time step (s)
  REAL(wp)   ,INTENT(IN)    :: pgeoh(klon,klev+1) ! geopotential height (above ground level) at model layer interfaces
  REAL(wp)   ,INTENT(IN)    :: mfb(klon)          ! bulk/first-guess mass flux derived from T-B scheme (normalised by grid cell area)
  REAL(wp)   ,INTENT(IN)    :: shfl(klon)         ! surface sensible heat flux
  REAL(wp)   ,INTENT(IN)    :: lhfl(klon)         ! surface latent heat flux 
  REAL(wp)   ,INTENT(IN)    :: temp_s(klon)       ! temperature on lowest model level
  REAL(wp)   ,INTENT(OUT)   :: mfp(klon)          ! stochastic perturbed mass flux, all clouds (diagnostic)
  REAL(wp)   ,INTENT(IN)    :: dh(klon)           ! moist static energy difference updraft/environment at cloud base
  INTEGER(i4),INTENT(IN)    :: ktype(klon)        ! convection type (0:off, 1:deep, 2:shallow, 3:mid-level)
  ! prognostic cloud numbers are given in units of "clouds per grid cell area"
  REAL(wp)   ,INTENT(INOUT) :: pclnum_a(klon)     ! prognostic active cloud number
  ! prognostic stochastic mass flux is given in units of kg s-1 m-2, i.e. per unit area
  REAL(wp)   ,INTENT(INOUT) :: pclmf_a(klon)      ! prognostic active mass flux
  REAL(wp)   ,INTENT(INOUT) :: pclnum_p(klon)     ! prognostic passive cloud number
  REAL(wp)   ,INTENT(INOUT) :: pclmf_p(klon)      ! prognostic passive mass flux
  REAL(wp)   ,INTENT(OUT)   :: clnum(klon)        ! diagnostic number of clouds per grid cell
  INTEGER(i4),INTENT(IN)    :: lseed(klon)        ! seed for random number generator
  REAL(wp)   ,INTENT(INOUT), DIMENSION(:,:,:), OPTIONAL :: extra_3d! 3D extra diagnostics
  LOGICAL    ,INTENT(IN)    :: luse3d             ! logical to switch on output of extra 3D diagnostics
  REAL(wp)   ,INTENT(IN)    :: cell_area(klon)    ! grid cell area
  LOGICAL    ,INTENT(IN)    :: lspinup            ! switches on cloud ensemble spinup
  ! This option enables instant spinup of the cloud ensemble
  ! into equilibrium with the large scale forcing (on average over many realisations, MF equals that of bulk MF).
  ! Normally, the cloud ensemble slowly develops over multiple time steps. For starts during actively convecting periods,
  ! instant spinup may be the preferred option.
  LOGICAL    ,INTENT(IN)    :: lgrayzone          ! switches on grayzone tuning

  !! Local variables
  REAL(wp), DIMENSION(klon) :: mavg2              ! expected mass flux of active cloud distribution
  REAL(wp), DIMENSION(klon) :: lambda2            ! distribution parameter for active Weibull distribution
  REAL(wp), DIMENSION(klon) :: M                  ! total bulk mass flux in each cell (not normalised by grid cell area)
  REAL(wp), DIMENSION(klon) :: hbas_con           ! convective cloud base height
  REAL(wp), DIMENSION(klon) :: mf_new_a,mf_new_p  ! increase of MF due to newly born clouds
  REAL(wp), DIMENSION(klon) :: mf_die_a,mf_die_p  ! decrease of MF due to dying clouds
  REAL(wp), DIMENSION(klon) :: birth_rate_a, birth_rate_p  ! birth rates active/passive clouds
  REAL(wp), DIMENSION(klon) :: death_rate_a, death_rate_p  ! death rates active/passive clouds
  REAL(wp), DIMENSION(klon) :: mean_m_a, mean_m_p ! average MF of active/passive clouds currently occupying grid cell
  REAL(wp), DIMENSION(klon) :: pclnum_now_a, pclnum_now_p  ! cloud ensemble state at beginning of time step
  REAL(wp), DIMENSION(klon) :: pclmf_now_a, pclmf_now_p    ! cloud ensemble state at beginning of time step
  
  REAL(wp) :: bowen                               ! Bowen ratio
  REAL(wp) :: lambda1                             ! distribution parameter for passive Weibull distribution
  REAL(wp) :: maxdeathrate                        ! max limit on death rate
  REAL(wp) :: dxy                                 ! grid cell area
  REAL(wp) :: rdxy                                ! inverse of grid cell area
  REAL(wp) :: eps                                 ! equivalent of 0.9 clouds in units of "clouds per grid cell area"
  REAL(wp) :: excess                              ! number of clouds exceeding upper limit (5000)
  REAL(wp) :: z0                              

  INTEGER(i4) :: i, k, kstart,kstop,idx           ! (loop) indices
  INTEGER(i4) :: rn_poisson1, rn_poisson2         ! result (integer) of draw from Poisson distribution
  INTEGER(i4) :: rn_poisson3, rn_poisson4,rn1,rn2 ! result (integer) of draw from Poisson distribution
  INTEGER(i4) :: iseed                            ! local copy of seed for random number generator
  INTEGER(i4) :: streammax                        ! length of random number sequence to be generated at once
  
  ! This is a hold-over from the explicit scheme, where clouds are kept explicitly in memory. In the SDE, this limit
  ! is not strictly necessary. However, the number of possible clouds also gives the upper limit on how many random
  ! numbers are generated at once, and here a limit must be defined. For consistency, the same value of possible
  ! clouds is chosen here as in the explicity scheme.
  
  REAL(wp), DIMENSION(5120) :: rn_u              ! sequence of random numbers generated by call to generator
  ! The max number of random numbers that can be retrieved from the generator is hardcoded, currently to 5120
 
  ! Type for random number generator and stream for producing random
  ! numbers
  TYPE(rng_type) :: random_number_generator

  REAL(wp), PARAMETER :: pi = 3.14159265358

!------------------------------------------------------------
  ! Distribution parameter for passive Weibull distribution is invariant, so calculate just once
  lambda1 = mavg1 / GAMMA(1.+kinv)

  !! Loop over grid points
  DO i = i_startidx, i_endidx

     pclnum_now_a(i)=pclnum_a(i)
     pclnum_now_p(i)=pclnum_p(i)
     pclmf_now_a(i) =pclmf_a(i)
     pclmf_now_p(i) =pclmf_p(i)
     
     !Initialize
     birth_rate_a(i)=0._WP
     birth_rate_p(i)=0._WP
     death_rate_a(i)=0._WP
     death_rate_p(i)=0._WP

     ! specify grid cell area
     dxy     = cell_area(i)
     ! inverse of grid cell area
     rdxy    = 1._WP/dxy
     ! equivalent of .9 clouds in units of clouds per unit area
     ! needed for checks of cloud numbers > zero
     eps     = .9*rdxy

     ! Only consider grid cells with active shallow convection
     ! If the grayzone tuning is used (not recommended with stochastic scheme)
     ! ktype=1 (deep) will also be used.
     IF (ktype(i) == 2 .OR. (lgrayzone .AND. ktype(i) == 1)) THEN

        ! CALCULATION OF WEIBULL DISTRIBUTION PARAMETERS FOR ACTIVE/PASSIVE CLOUD POPULATIONS
        ! AND CALCULATION OF BIRTH RATES BASED ON Sakradzija and Hohenegger 2017
        
        ! Bulk mass flux from traditional T-B closure, convert into units of kg/s
        ! by multiplying with grid box area
        M(i)  = mfb(i)*dxy ! in kg/s; rho =1 kg/m3
        ! calculate Bowen ratio. Make sure bowen cannot become zero!
        IF (shfl(i)>=0._WP.OR.lhfl(i)>=0._WP) THEN 
           bowen = 0._WP
        ELSE
           bowen = shfl(i)/lhfl(i)+1e-13_WP ! 1.e-13 added as safety against zero value
        ENDIF
        ! depth of subcloud layer, based on convective cloud base layer determined by test parcel ascent
        hbas_con(i) = pgeoh(i,mbas_con(i))

        ! Calculate distribution avgerage mass flux mavg2 for active clouds
        ! based on Eqn 12 Sakradzija and Hohenegger 2017
        mavg2(i)  = m0 + C1 * ( bowen/(1+bowen) + 0.608_WP*cpd*temp_s(i)/(alv+bowen*alv) ) * &
                      hbas_con(i)*0.5_WP/(cpd*temp_s(i)) * & 
                      (-shfl(i)-lhfl(i))/dh(i)

        ! Check: use Bowen ratio to calculate mavg2 only if surface fluxes are into the atmosphere
        ! otherwise reduce expression for mavg2 to intercept parameter m0
        ! Rescaling is then necessary (since fixed parameters were derived for LES resolution)
        IF (shfl(i)>=0._WP.OR.lhfl(i)>=0._WP) THEN 
          mavg2(i)  = m0 * 51200._WP * 51200._WP
        ELSE
          mavg2(i)  = mavg2(i) * 51200._WP * 51200._WP
          mavg2(i)  = MAX(mavg2(i),10000._WP)
        ENDIF
        
        ! heat-cycle dependent Weibull parameter for active clouds
        lambda2(i) = mavg2(i) / GAMMA(1.+kinv)

        ! Derive birth rates for passive/active clouds
        ! The "active_fraction" determines what fraction of the bulk MF will be represented by active vs. passive clouds
        ! Default: active_fraction=0.6, as a fixed parameter
        birth_rate_a(i) = active_fraction*M(i)/(alpha_mf*lambda2(i)**(beta_mf+1)* &
             & gamma(1.+(beta_mf+1)*kinv))
        birth_rate_p(i) = (1._WP-active_fraction)*M(i)/(alpha_mf*lambda1**(beta_mf+1)* &
             & gamma(1._WP+(beta_mf+1)*kinv))

        !! CALCULATION OF DEATH RATES BASED ON Machulskaya and Seifert 2019
        
        ! Calculate death rates only if non-zero clouds and mass flux exist
        IF(pclnum_now_a(i) > eps .AND. pclmf_now_a(i) > 0._WP) THEN
           ! mean_m_a is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for active clouds
           mean_m_a(i) = pclmf_now_a(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_a(i)*dxy*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing active cloud.
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           maxdeathrate=pclnum_now_a(i)*dxy/ptsphy
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of active clouds
           death_rate_a(i) = pclnum_now_a(i)*dxy/MAX(alpha_mf*(mean_m_a(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Apply death rate limit
           death_rate_a(i)= MIN(death_rate_a(i),maxdeathrate)
        ELSE
           ! If no active clouds exist, death rate is zero.
           mean_m_a(i) = 0.0
           death_rate_a(i) = 0.0 
        END IF
        IF(pclnum_now_p(i) > eps .AND. pclmf_now_p(i) >0._WP ) THEN
           ! mean_m_p is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for passive clouds
           mean_m_p(i) = pclmf_now_p(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_p(i)*dxy*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing passve clouds.
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           maxdeathrate=pclnum_now_p(i)*dxy/ptsphy
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of passive clouds
           death_rate_p(i) = pclnum_now_p(i)*dxy/MAX(alpha_mf*(mean_m_p(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Apply death rate limit
           death_rate_p(i)= MIN(death_rate_p(i),maxdeathrate)
        ELSE
           ! If no passive clouds exist, death rate is zero.
           mean_m_p(i) = 0.0
           death_rate_p(i) = 0.0 
        END IF
      ELSE !ktype!=2
        ! If grid cell has no active shallow convection, continue decaying number and massflux according to death rate.
        ! While the mass flux calculated for this time step is not actively used by the convection scheme,
        ! the state of the decaying cloud ensemble may be picked up again if convection switches back on during
        ! subsequent time steps.
        IF(pclnum_now_a(i) > eps .AND. pclmf_now_a(i) > 0._WP) THEN
           ! mean_m_p is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for active clouds
           mean_m_a(i) = pclmf_now_a(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_a(i)*dxy*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of active clouds
           death_rate_a(i) = pclnum_now_a(i)*dxy/MAX(alpha_mf*(mean_m_a(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing active clouds
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           death_rate_a(i)= MIN(death_rate_a(i),pclnum_now_a(i)*dxy/ptsphy)!*.8_WP
        ELSE
           ! If no active clouds exist, death rate is zero.
           mean_m_a(i) = 0.0
           death_rate_a(i) = 0.0 
        END IF
        IF(pclnum_now_p(i) > eps .AND. pclmf_now_p(i) > 0._WP) THEN
           ! mean_m_p is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for passive clouds
           mean_m_p(i) = pclmf_now_p(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_p(i)*dxy*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of passive clouds
           death_rate_p(i) = pclnum_now_p(i)*dxy/MAX(alpha_mf*(mean_m_p(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing passve clouds
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           death_rate_p(i)= MIN(death_rate_p(i),pclnum_now_p(i)*dxy/ptsphy)!*.8_WP
        ELSE
           ! If no passive clouds exist, death rate is zero.
           mean_m_p(i) = 0.0
           death_rate_p(i) = 0.0 
        END IF

        ! Update prognostic mass flux
        pclmf_a(i)=pclmf_now_a(i)
        pclmf_p(i)=pclmf_now_p(i)
      ENDIF !ktype !=2
    ENDDO ! istart_idx

    ! RANDOM NUMBER GENERATION AND DETERMINATION OF NUMBER OF NEWBORN CLOUDS BY DRAW FROM
    ! POISSON DISTRIBUTION
    ! Separate loop for random_Poisson call because it doesn't vectorise on NEC

    ! Loop over grid points
    DO i = i_startidx, i_endidx

      ! The random seed for each grid point is calculated based on lat, lon, forecast time and ensemble number,
      ! such that the seed is reproducable for subsequent runs. NOTE: the seed is not updated in this routine!
      iseed=lseed(i)

      ! Get sufficient random numbers for four calls to the random_Poisson routine. This routine iterates, and
      ! 50 random numbers per call is a very conservative estimate of the random numbers needed.
      streammax=200
      ! Initialise the random number generator
      CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
        &                                  nmaxstreams=streammax)
      ! Retrieve streammax new random numbers to use in draw from Poisson distributions
      CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

#ifdef HAVE_ACM_LICENSE         
      ! Determine number of newborn active clouds by drawing from Poisson distribution with given birth rate.
      idx=1 ! This index keeps track of which random numbers out of the 200 have already been used
      rn_poisson1 = random_Poisson(birth_rate_a(i)*ptsphy,idx,streammax,rn_u(1:streammax))
      ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
      IF (idx > streammax) THEN
         WRITE(6,*) 'idx1 out of range',idx,birth_rate_a(i)*ptsphy,rn_u(1),rn_u(idx),MINVAL(rn_u(1:streammax)),MAXVAL(rn_u(1:streammax))
      ENDIF
      
      ! Determine number of dying active clouds by drawing from Poisson distribution with given death rate.
      idx=50 ! Start at index 50, to make sure to use "fresh" random numbers
      rn_poisson2 = random_Poisson(death_rate_a(i)*ptsphy,idx,streammax,rn_u(1:streammax))
      ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
      IF (idx > streammax) THEN
         WRITE(6,*) 'idx2 out of range',idx,death_rate_a(i)*ptsphy,rn_u(1),rn_u(idx),MINVAL(rn_u(1:streammax)),MAXVAL(rn_u(1:streammax))
      ENDIF

      ! Determine number of newborn passive clouds by drawing from Poisson distribution with given birth rate.
      idx=100 ! Start at index 100, to make sure to use "fresh" random numbers
      rn_poisson3 = random_Poisson(birth_rate_p(i)*ptsphy,idx,streammax,rn_u(1:streammax))
      ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
      IF (idx > streammax) THEN
         write(6,*) 'idx3 out of range',idx,birth_rate_p(i)*ptsphy,rn_u(1),rn_u(idx),MINVAL(rn_u(1:streammax)),MAXVAL(rn_u(1:streammax))
      ENDIF
      
      ! Determine number of dying passive clouds by drawing from Poisson distribution with given death rate.
      idx=150 ! Start at index 150, to make sure to use "fresh" random numbers
      rn_poisson4 = random_Poisson(death_rate_p(i)*ptsphy,idx,streammax,rn_u(1:streammax))
      ! Safety check in case random_Poisson routine does not converge and runs out of random numbers to use
      IF (idx > streammax) THEN
         WRITE(6,*) 'idx4 out of range',idx,death_rate_p(i)*ptsphy,rn_u(1),rn_u(idx),MINVAL(rn_u(1:streammax)),MAXVAL(rn_u(1:streammax))
      ENDIF
      idx=200
#else
      ! Determine number of newborn active clouds by sampling a normal distribution
      ! (instead of Poisson) using the Box-Muller method, with given birth rate.
      idx=1 ! This index keeps track of which random numbers out of the 200 have already been used
      z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
      rn_poisson1 = MAX(0,INT(z0 * SQRT(birth_rate_a(i)*ptsphy) + birth_rate_a(i)*ptsphy))
      
      ! Determine number of dying active clouds by sampling a normal distribution
      ! (instead of Poisson) using the Box-Muller method, with given death rate.
      idx=50 
      z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
      rn_poisson2 = MAX(0,INT(z0 * SQRT(death_rate_a(i)*ptsphy) + death_rate_a(i)*ptsphy))
      
      ! Determine number of newborn passive clouds by sampling a normal distribution
      ! (instead of Poisson) using the Box-Muller method, with given birth rate.
      idx=100 ! This index keeps track of which random numbers out of the 200 have already been used
      z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
      rn_poisson3 = MAX(0,INT(z0 * SQRT(birth_rate_p(i)*ptsphy) + birth_rate_p(i)*ptsphy))
      
      ! Determine number of dying passive clouds by sampling a normal distribution
      ! (instead of Poisson) using the Box-Muller method, with given death rate.
      idx=150 
      z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
      rn_poisson4 = MAX(0, INT(z0 * SQRT(death_rate_p(i)*ptsphy) + death_rate_p(i)*ptsphy))
      idx=200

#endif

      ! Initialise diagnostic fields that keep track of how much mass flux is added by newborn clouds,
      ! and how much is removed by dying clouds
      mf_new_a(i)=0._WP
      mf_die_a(i)=0._WP
      mf_new_p(i)=0._WP
      mf_die_p(i)=0._WP

      ! specify grid cell area (must be repeated because it's grid point dependent, and we're in a new loop)
      dxy     = cell_area(i)
      ! inverse of grid cell area
      rdxy    = 1._WP/dxy
      ! equivalent of .9 clouds in units of clouds per unit area
      ! needed for checks of cloud numbers > zero
      eps     = .9*rdxy

      ! Only consider grid cells with active shallow convection
      ! If the grayzone tuning is used (not recommended with stochastic scheme)
      ! ktype=1 (deep) will also be used.
      IF (ktype(i) == 2 .or. (lgrayzone .and. ktype(i) == 1)) THEN

        !update stochastic mass flux and cloud numbers
        pclmf_a(i)=pclmf_now_a(i)
        pclmf_p(i)=pclmf_now_p(i)
        pclnum_a(i)=pclnum_now_a(i)
        pclnum_p(i)=pclnum_now_p(i)

        ! SPINUP
        ! If the spinup option is enabled and we're on the first convection timestep, and
        ! any new clouds are to be generated, proceed...
        IF (lspinup .and. pclnum_a(i)+pclnum_p(i) == 0) THEN
           ! As first-guess prognostic mass flux, assign the 40%/60% passive/active
           ! split to the bulk mass flux
           pclmf_a(i)=active_fraction*mfb(i)
           pclmf_p(i)=(1._wp-active_fraction)*mfb(i)
           ! As a first-guess of the cloud numbers in the ensemble, divide the (grid box total)
           ! mass flux by the Weibull distribution's average cloud's mass flux
           ! Note, this number will not correspond to an integer but a real
           pclnum_a(i)=pclmf_a(i)/mavg2(i)
           pclnum_p(i)=pclmf_p(i)/mavg1
           ! Use the fractional first guess cloud number as expected value for a Poisson draw
           ! to generate a stochastic estimate of the actual active/passive cloud number (integer)
           ! in the grid box
#ifdef HAVE_ACM_LICENSE           
           rn1 = random_Poisson(pclnum_a(i)*dxy,idx,streammax,rn_u(1:streammax))
           rn2 = random_Poisson(pclnum_p(i)*dxy,idx,streammax,rn_u(1:streammax))
#else
           z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+1))
           rn1 = MAX(0, INT(z0 * SQRT(pclnum_a(i)*dxy) + pclnum_a(i)*dxy))
           z0 = SQRT(-2._wp * LOG(rn_u(idx+2))) * COS(pi * rn_u(idx+3))
           rn2 = MAX(0, INT(z0 * SQRT(pclnum_p(i)*dxy) + pclnum_p(i)*dxy))
           idx=idx+4
#endif
           ! To calculate the final estimate of the grid box mass flux, multiply the
           ! number of active/passive clouds again with the average mass flux of the
           ! Weibull distribution (mavg1, mavg2)
           pclmf_a(i)=rn1*mavg2(i)*rdxy
           pclmf_p(i)=rn2*mavg1*rdxy
           ! Convert the number of new clouds (integer) into units of cloud per grid box area
           pclnum_a(i)=float(rn1)*rdxy
           pclnum_p(i)=float(rn2)*rdxy
        ENDIF

        ! GENERATE RANDOM NUMBERS, AND DRAW EACH NEW CLOUD'S MASS FLUX FROM
        ! WEIBULL DISTRIBUTION

        ! Get a random number for each newly born/dying cloud, plus 200 extra
        ! so we can throw out the first 200 that were already used for the Poisson draws.
        streammax=rn_poisson1+rn_poisson2+rn_poisson3+rn_poisson4+idx
        
        ! Safety check - we can draw only 5120 random numbers at a time. This
        ! limit is hard-coded into the random number generator.
        ! For resolutions up to 5km, this limit should never be reached, but in 
        ! case this code is run at very coarse resolutions, this will make sure
        ! the number is capped at the limit. Note: As an added safety feature,
        ! lstoch_sde is set to .false. for resolutions above 20km in the physics
        ! setup.
        ! Reduce cloud numbers equally in all categories of active/passive/born/dying clouds.
        IF (streammax > 5120) THEN
           excess=streammax/5120._WP-1._WP
           rn_poisson3=rn_poisson3-CEILING(excess*(rn_poisson3+idx*.25))
           rn_poisson4=rn_poisson4-CEILING(excess*(rn_poisson4+idx*.25))
           rn_poisson1=rn_poisson1-CEILING(excess*(rn_poisson1+idx*.25))
           rn_poisson2=rn_poisson2-CEILING(excess*(rn_poisson2+idx*.25))
           streammax=rn_poisson1+rn_poisson2+rn_poisson3+rn_poisson4+idx
        ENDIF
        
        ! Initialize and retrieve only as many random numbers as will be needed - speeds up code
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
             &                                  nmaxstreams=streammax)
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        kstart=idx+1 ! Start using first random number at 201
        kstop=idx+rn_poisson1
        DO k = kstart, kstop
           ! Randomly draw mass flux from Weibull distribution for active clouds
           ! The cloud's mass flux is given by Eqn 3 Sakradzija and Klocke, 2018.
           pclmf_a(i) = pclmf_a(i) + (-LOG(1.-rn_u(k))*(lambda2(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux added in diagnostic
           mf_new_a(i)=mf_new_a(i)+(-LOG(1.-rn_u(k))*(lambda2(i)**k_wei))**kinv*rdxy
        END DO

        
        kstart=kstop+1
        kstop=kstop+rn_poisson2
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_a
           pclmf_a(i) = pclmf_a(i) - (-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux lost in diagnostic
           mf_die_a(i)=mf_die_a(i)+(-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
        END DO

        ! Repeat for passive clouds
        kstart=kstop+1
        kstop=kstop+rn_poisson3
        DO k =kstart,kstop
           ! Randomly draw mass flux from Weibull distribution for passive clouds
           ! The cloud's mass flux is given by Eqn 3 Sakradzija and Klocke, 2018.
           pclmf_p(i) = pclmf_p(i) + (-LOG(1.-rn_u(k))*(lambda1**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux added in diagnostic
           mf_new_p(i)=mf_new_p(i)+(-LOG(1.-rn_u(k))*(lambda1**k_wei))**kinv*rdxy
        END DO

        kstart=kstop+1
        kstop=kstop+rn_poisson4
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_p
           pclmf_p(i) = pclmf_p(i) - (-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux lost in diagnostic
           mf_die_p(i)=mf_die_p(i)+(-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
        END DO

        ! Update prognostic cloud numbers, and check for negative values
        ! Note: prognostic cloud numbers have units of "clouds per grid box area"
        pclnum_a(i) = pclnum_a(i) + float(rn_poisson1 - rn_poisson2)*rdxy
        pclnum_a(i) = MAX(pclnum_a(i),0._wp)
        pclmf_a (i) = MAX(pclmf_a (i),0._wp)

        pclnum_p(i) = pclnum_p(i) + float(rn_poisson3 - rn_poisson4)*rdxy
        pclnum_p(i) = MAX(pclnum_p(i),0._wp)
        pclmf_p (i) = MAX(pclmf_p (i),0._wp)

        ! Enforce consistency between mass flux and cloud numbers
        ! Check if cloud numbers have dropped below 0.9, and
        ! remove any remaining MF if that is the case
        IF (pclnum_a(i) <= eps) THEN
           ! if remaining MF is removed because no cloud is left
           ! update diagnostic for MF removed by dying clouds
           !??? is this correct?
           mf_die_a(i)=mf_die_a(i)+pclmf_a(i)
           pclmf_a (i) = 0._wp
        ENDIF
        IF (pclnum_p(i) <= eps) THEN
           ! if remaining MF is removed because no cloud is left
           ! update diagnostic for MF removed by dying clouds
           !??? is this correct?
           mf_die_p(i)=mf_die_p(i)+pclmf_p(i)
           pclmf_p (i) = 0._wp
        ENDIF
        
        ! update diagnostic variables for total (active+passive) MF and cloud numbers
        mfp(i)=pclmf_a(i)+pclmf_p(i)
        ! Diagnostic uses absolute cloud number, not number per unit area
        clnum(i)=(pclnum_a(i)+pclnum_p(i))*dxy
        ! get rid of very small values 1e-16 left by unit conversion
        IF (clnum(i) < .1_WP) clnum(i)= 0.0_WP 

        IF (luse3d) THEN 
          ! write diagnostics
          extra_3d(i,1,2)=birth_rate_p(i)*ptsphy        ! passive birth rate (in units of clouds per time step)
          extra_3d(i,2,2)=birth_rate_a(i)*ptsphy        ! active birth rate (in units of clouds per time step)
          extra_3d(i,3,2)=pclnum_p(i)*dxy               ! current number of prognostic passive clouds (number)
          extra_3d(i,4,2)=pclnum_a(i)*dxy               ! current number of prognostic active clouds (number)
          extra_3d(i,5,2)=float(rn_poisson3)            ! newborn passive clouds (number)
          extra_3d(i,6,2)=float(rn_poisson4)            ! dying   passive clouds (number)
          extra_3d(i,7,2)=float(rn_poisson1)            ! newborn active clouds (number)
          extra_3d(i,8,2)=float(rn_poisson2)            ! dying   active clouds (number)
          extra_3d(i,9,2)=(pclnum_a(i)+pclnum_p(i))*dxy ! total number of clouds (active+passive)
          extra_3d(i,10,2)=pclmf_a(i)+pclmf_p(i)        ! total mass flux (per unit area)
          extra_3d(i,11,2)=mf_new_p(i)                  ! MF of newborn passive clouds
          extra_3d(i,12,2)=mf_die_p(i)                  ! MF of dying   passive clouds
          extra_3d(i,13,2)=mf_new_a(i)                  ! MF of newborn active clouds
          extra_3d(i,14,2)=mf_die_a(i)                  ! MF of dying   active clouds
          extra_3d(i,15,2)=lambda1                      ! Weibull parameter passiv clouds
          extra_3d(i,16,2)=lambda2(i)                   ! Weibull parameter active clouds
          extra_3d(i,17,2)=mean_m_p(i)                  ! Expected value of Weibull dist. of current passive cloud ensemble
          extra_3d(i,18,2)=mean_m_a(i)                  ! Expected value of Weibull dist. of current active  cloud ensemble
          extra_3d(i,19,2)=death_rate_p(i)*ptsphy       ! passive death rate (in units of clouds per time step)
          extra_3d(i,20,2)=death_rate_a(i)*ptsphy       ! active death rate (in units of clouds per time step)
        ENDIF 
      ELSE !not ktype=2
        ! If grid cell has no active shallow convection, continue decaying number and massflux according to death rate.
        ! While the mass flux calculated for this time step is not actively used by the convection scheme,
        ! the state of the decaying cloud ensemble may be picked up again if convection switches back on during
        ! subsequent time steps.

        ! We only need to generate random numbers for dying clouds +200 used for prior Poisson draw 
        streammax=rn_poisson2+rn_poisson4+idx
        ! Safety check again that random numbers to be drawn don't exceed the hard-coded max limit,
        ! and reduce numbers if necessary.
        IF (streammax > 5120) THEN
           excess=streammax/5120._WP-1._WP
           rn_poisson4=rn_poisson4-CEILING(excess*(rn_poisson4+idx*.5))
           rn_poisson2=rn_poisson2-CEILING(excess*(rn_poisson2+idx*.5))
           streammax=rn_poisson2+rn_poisson4+idx
        ENDIF
        ! Initialise random number call
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
             &                                  nmaxstreams=streammax)
        ! Call random number generator to get sequence of random numbers
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        kstart=idx+1
        kstop=idx+rn_poisson2
        DO k = kstart,kstop
           !???Why am I calculating this here again?
           mean_m_a(i) = pclmf_now_a(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_a(i)*dxy* &
                & gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_a
           pclmf_a(i) = pclmf_a(i) - (-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux lost in diagnostic
           mf_die_a(i)=mf_die_a(i)+(-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
        END DO

        kstart=kstop+1
        kstop=kstop+rn_poisson4
        DO k = kstart,kstop
           !???Why am I calculating this here again?
           mean_m_p(i) = pclmf_now_p(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(pclnum_now_p(i)*dxy* &
                & gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_p
           pclmf_p(i) = pclmf_p(i) - (-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux lost in diagnostic
           mf_die_p(i)=mf_die_p(i)+(-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
        END DO

        ! Update prognostics cloud numbers and ensure no negative cloud numbers
        ! or mass flux may exist
        pclnum_a(i) = pclnum_now_a(i) - float(rn_poisson2)*rdxy
        pclnum_a(i) = MAX(pclnum_a(i),0._wp)
        pclnum_p(i) = pclnum_now_p(i) - float(rn_poisson4)*rdxy
        pclnum_p(i) = MAX(pclnum_p(i),0._wp)
        pclmf_p (i) = MAX(pclmf_p (i),0._wp)
        pclmf_a (i) = MAX(pclmf_a (i),0._wp)
        
        ! Enforce consistency between MF and cloud numbers
        ! Check if cloud numbers have dropped below 0.9, and
        ! remove any remaining MF if that is the case
        IF (pclnum_a(i) <= eps) THEN
           ! if remaining MF is removed because no cloud is left
           ! update diagnostic for MF removed by dying clouds
           mf_die_a(i)=mf_die_a(i)+pclmf_a(i)
           pclmf_a (i) = 0._wp
        ENDIF
        IF (pclnum_p(i) <= eps) THEN
           ! if remaining MF is removed because no cloud is left
           ! update diagnostic for MF removed by dying clouds
           mf_die_p(i)=mf_die_p(i)+pclmf_p(i)
           pclmf_p (i) = 0._wp
        ENDIF

        ! update diagnostic variables for total (active+passive) MF and cloud numbers
        mfp(i)=pclmf_a(i)+pclmf_p(i)
        ! Diagnostic uses absolute cloud number, not number per unit area
        clnum(i)=(pclnum_a(i)+pclnum_p(i))*dxy
        ! get rid of very small values 1e-16 left by unit conversion
        IF (clnum(i) < .1_WP) clnum(i)= 0.0_WP

        IF (luse3d) THEN 
          ! write extra diagnostics
          extra_3d(i,1,2)=0.                            ! passive birth rate (in units of clouds per time step)
          extra_3d(i,2,2)=0.                            ! active birth rate (in units of clouds per time step)
          extra_3d(i,3,2)=pclnum_p(i)*dxy               ! current number of prognostic passive clouds (number)
          extra_3d(i,4,2)=pclnum_a(i)*dxy               ! current number of prognostic active clouds (number)
          extra_3d(i,5,2)=0.                            ! newborn passive clouds (number)
          extra_3d(i,6,2)=float(rn_poisson4)            ! dying   passive clouds (number)
          extra_3d(i,7,2)=0.                            ! newborn active clouds (number)
          extra_3d(i,8,2)=float(rn_poisson2)            ! dying   active clouds (number)
          extra_3d(i,9,2)=(pclnum_a(i)+pclnum_p(i))*dxy ! total number of clouds (active+passive)
          extra_3d(i,10,2)=pclmf_a(i)+pclmf_p(i)        ! total mass flux (per unit area)
          extra_3d(i,11,2)=0.                           ! mf of newborn passive clouds
          extra_3d(i,12,2)=mf_die_p(i)                  ! mf of dying   passive clouds
          extra_3d(i,13,2)=0.                           ! mf of newborn active clouds
          extra_3d(i,14,2)=mf_die_a(i)                  ! mf of dying   active clouds
          extra_3d(i,15,2)=0.                           ! Weibull parameter passiv clouds
          extra_3d(i,16,2)=0.                           ! Weibull parameter active clouds
          extra_3d(i,17,2)=mean_m_p(i)                  ! Expected value of Weibull dist. of current passive cloud ensemble
          extra_3d(i,18,2)=mean_m_a(i)                  ! Expected value of Weibull dist. of current active  cloud ensemble
          extra_3d(i,19,2)=death_rate_p(i)*ptsphy       ! passive death rate (in units of clouds per time step)
          extra_3d(i,20,2)=death_rate_a(i)*ptsphy       ! active death rate (in units of clouds per time step)
        ENDIF
      ENDIF
  ENDDO
  END SUBROUTINE shallow_stoch_sde
!________________________________________________________________________________________________
!________________________________________________________________________________________________
!________________________________________________________________________________________________
  !
  ! When running SDE passively in piggy-back-mode, calculate birth/death rates and
  ! updated cloud mass flux and numbers as extra diagnostics, based on model state
  ! of previous timestep.
  ! A separate routine is created for this purpose because the interface does not include
  ! the same variables - the four prognostic variables describing the SDE system are only
  ! defined if the SDE scheme is run interactively. The only output from this routine
  ! is the 3D extra variable containing extra diagnostics.
  
  SUBROUTINE shallow_stoch_sde_passive(i_startidx,i_endidx,klon,klev,ptsphy,pgeoh,mbas_con,&
                           & mfb, shfl, lhfl, temp_s,dh, ktype, &
                           & extra_3d,mfp,mfa,clnum_p,clnum_a,lseed,luse3d,cell_area,lgrayzone)

  !run stochastic scheme globaly 


  INTEGER(i4),INTENT(IN)    :: i_startidx         ! block index start
  INTEGER(i4),INTENT(IN)    :: i_endidx           ! block index end
  INTEGER(i4),INTENT(IN)    :: klon               ! number of grid points in block
  INTEGER(i4),INTENT(IN)    :: klev               ! number of model layers
  INTEGER(i4),INTENT(IN)    :: mbas_con(klon)     ! model level index of cloud base (LCL)
  REAL(wp)   ,INTENT(IN)    :: ptsphy             ! length of physics time step (s)
  REAL(wp)   ,INTENT(IN)    :: pgeoh(klon,klev+1) ! geopotential height (above ground level) at model layer interfaces
  REAL(wp)   ,INTENT(IN)    :: mfb(klon)          ! bulk/first-guess mass flux derived from T-B scheme (normalised by grid cell area)
  REAL(wp)   ,INTENT(IN)    :: shfl(klon)         ! surface sensible heat flux
  REAL(wp)   ,INTENT(IN)    :: lhfl(klon)         ! surface latent heat flux
  REAL(wp)   ,INTENT(IN)    :: temp_s(klon)       ! temperature on lowest model level
  REAL(wp)   ,INTENT(IN)    :: dh(klon)           ! moist static energy difference updraft/environment at cloud base
  INTEGER(i4),INTENT(IN)    :: ktype(klon)        ! convection type (0:off, 1:deep, 2:shallow, 3:mid-level)
  REAL(wp)   ,INTENT(INOUT), DIMENSION(:,:,:), OPTIONAL :: extra_3d ! 3D extra diagnostics
  REAL(wp)   ,INTENT(IN)    :: mfp(klon)          ! passive clouds mass flux from previous time step (diagnostic)
  REAL(wp)   ,INTENT(IN)    :: mfa(klon)          ! active  clouds mass flux from previous time step (diagnostic)
  REAL(wp)   ,INTENT(IN)    :: clnum_p(klon)      ! number passive clouds from previous time step (diagnostic)
  REAL(wp)   ,INTENT(IN)    :: clnum_a(klon)      ! number active clouds from previous time step (diagnostic)
  INTEGER(i4),INTENT(IN)    :: lseed(klon)        ! seed for random number generator 
  LOGICAL    ,INTENT(IN)    :: luse3d             ! logical to switch on output of extra 3D diagnostics
  REAL(wp)   ,INTENT(in)    :: cell_area(klon)    ! grid cell area
  LOGICAL    ,INTENT(in)    :: lgrayzone          ! switches on grayzone tuning

  REAL(wp), DIMENSION(klon) :: mavg2              ! expected mass flux of active cloud distribution
  REAL(wp), DIMENSION(klon) :: lambda2            ! distribution parameter for active Weibull distribution
  REAL(wp), DIMENSION(klon) :: M                  ! total bulk mass flux in each cell (not normalised by grid cell area)
  REAL(wp), DIMENSION(klon) :: hbas_con           ! convective cloud base height
  REAL(wp), DIMENSION(klon) :: mf_new_a,mf_new_p  ! increase of MF due to newly born clouds
  REAL(wp), DIMENSION(klon) :: mf_die_a,mf_die_p  ! decrease of MF due to dying clouds
  REAL(wp), DIMENSION(klon) :: birth_rate_a, birth_rate_p  ! birth rates active/passive clouds
  REAL(wp), DIMENSION(klon) :: death_rate_a, death_rate_p  ! death rates active/passive clouds
  REAL(wp), DIMENSION(klon) :: mean_m_a, mean_m_p ! average MF of active/passive clouds currently occupying grid cell

  REAL(wp) :: bowen                               ! Bowen ratio
  REAL(wp) :: lambda1                             ! distribution parameter for passive Weibull distribution
  REAL(wp) :: maxdeathrate                        ! max limit on death rate
  REAL(wp) :: dxy                                 ! grid cell area
  REAL(wp) :: rdxy                                ! inverse of grid cell area
  REAL(wp) :: tempmf                              ! active+passive grid cell mass flux at previous time step
  REAL(wp) :: excess                              ! number of clouds exceeding upper limit (5000)
  REAL(wp) :: z0  

  INTEGER(i4) :: i, k, kstart,kstop,idx           ! (loop) indices
  INTEGER(i4) :: rn_poisson1, rn_poisson2         ! result (integer) of draw from Poisson distribution
  INTEGER(i4) :: rn_poisson3, rn_poisson4,rn1,rn2 ! result (integer) of draw from Poisson distribution
  INTEGER(i4) :: iseed                            ! local copy of seed for random number generator
  INTEGER(i4) :: streammax                        ! length of random number sequence to be generated at once
  
  REAL(wp), DIMENSION(5120) :: rn_u               ! sequence of random numbers generated by call to generator
  ! The max number of random numbers that can be retrieved from the generator is hardcoded, currently to 5120
  
  ! Type for random number generator and stream for producing random
  ! numbers
  TYPE(rng_type) :: random_number_generator
  
  REAL(wp), PARAMETER :: pi = 3.14159265358

  !------------------------------------------------------------
  ! Distribution parameter for passive Weibull distribution is invariant, so calculate just once
  lambda1 = mavg1 / GAMMA(1.+kinv)

  !! Loop over grid points
  DO i = i_startidx, i_endidx

     !Initialize
     birth_rate_a(i)=0._WP
     birth_rate_p(i)=0._WP
     death_rate_a(i)=0._WP
     death_rate_p(i)=0._WP
     
     ! specify grid cell area
     dxy     = cell_area(i)
     ! inverse of grid cell area
     rdxy    = 1._WP/dxy

     ! Only consider grid cells with active shallow convection
     ! If the grayzone tuning is used (not recommended with stochastic scheme)
     ! ktype=1 (deep) will also be used.
      IF (ktype(i) == 2 .or. (lgrayzone .and. ktype(i) == 1)) THEN

        ! bulk mass flux from first call to convection, convert into units of kg/s
        ! by multiplying with grid box area
        M(i)  = mfb(i)*dxy ! in kg/s; rho =1 kg/m3
        ! calculate Bowen ratio. Make sure bowen cannot become zero!
        if (shfl(i)>=0._WP.OR.lhfl(i)>=0._WP) then
           bowen = 0._WP
        ELSE
           bowen = shfl(i)/lhfl(i)+1e-13_WP ! 1.e-13 added as safety against zero value
        ENDIF
        ! depth of subcloud layer, based on convective cloud base layer determined by test parcel ascent
        hbas_con(i) = pgeoh(i,mbas_con(i))

        ! Calculate distribution avgerage mass flux mavg2 for active clouds
        ! based on Eqn 12 Sakradzija and Hohenegger 2017
        mavg2(i)  = m0 + C1 * ( bowen/(1+bowen) + 0.608_WP*cpd*temp_s(i)/(alv+bowen*alv) ) * &
                      hbas_con(i)*0.5_WP/(cpd*temp_s(i)) * & 
                      (-shfl(i)-lhfl(i))/dh(i)
        
        ! Check: use Bowen ratio to calculate mavg2 only if surface fluxes are into the atmosphere
        ! otherwise reduce expression for mavg2 to intercept parameter m0
        ! Rescaling is then necessary (since fixed parameters were derived for LES resolution)
        if (shfl(i)>=0._WP.OR.lhfl(i)>=0._WP) then 
          mavg2(i)  = m0 * 51200._WP * 51200._WP
        else
          mavg2(i)  = mavg2(i) * 51200._WP * 51200._WP
          mavg2(i)  = MAX(mavg2(i),10000._WP)
        endif
        
        ! heat-cycle dependent Weibull parameter for active clouds
        lambda2(i) = mavg2(i) / GAMMA(1.+kinv)

        ! Derive birth rates for passive/active clouds
        ! The "active_fraction" determines what fraction of the bulk MF will be represented by active vs. passive clouds
        ! Default: active_fraction=0.6, as a fixed parameter
        birth_rate_a(i) = active_fraction*M(i)/(alpha_mf*lambda2(i)**(beta_mf+1)* &
             & gamma(1.+(beta_mf+1)*kinv))
        birth_rate_p(i) = (1.-active_fraction)*M(i)/(alpha_mf*lambda1**(beta_mf+1)* &
             & gamma(1.+(beta_mf+1)*kinv))

        !! CALCULATION OF DEATH RATES BASED ON Machulskaya and Seifert 2019
        
        ! Calculate death rates only if non-zero clouds and mass flux exist
        IF(clnum_a(i) >0. .AND. mfa(i) > 0._WP) THEN
           ! mean_m_a is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for active clouds
           mean_m_a(i) = mfa(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(clnum_a(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing active cloud.
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           maxdeathrate=clnum_a(i)/ptsphy
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of active clouds
           death_rate_a(i) = clnum_a(i)/MAX(alpha_mf*(mean_m_a(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Apply death rate limit
           death_rate_a(i)= MIN(death_rate_a(i),maxdeathrate)
        ELSE
           ! If no active clouds exist, death rate is zero.
          mean_m_a(i) = 0.0
          death_rate_a(i) = 0.0 
        END IF
        IF(clnum_p(i) >0. .and. mfp(i) > 0._WP) THEN
           ! mean_m_p is the distribution parameter m'_b in Eqn 26 of Machulskaya and Seifert 2019, for passive clouds
           mean_m_p(i) = mfp(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(clnum_p(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           ! Limit the death rate to a value corresponding to current number of existing passive cloud.
           ! This is required to avoid spuriously large expected values entering the Poisson routine, which then fails
           ! to converge.
           maxdeathrate=clnum_p(i)/ptsphy
           ! Here, the denominator is the conditional cloud life time as derived in Eqn 31 Machulskaya and Seifert 2017.
           ! The numerator is the current number of passive clouds
           death_rate_p(i) = clnum_p(i)/MAX(alpha_mf*(mean_m_p(i))**beta_mf*gamma(beta_mf*kinv+1.), 1.E-10_wp)
           ! Apply death rate limit
           death_rate_p(i)= MIN(death_rate_p(i),maxdeathrate)
        ELSE
           ! If no passive clouds exist, death rate is zero.
           mean_m_p(i) = 0.0
           death_rate_p(i) = 0.0
        END IF
      ENDIF
   ENDDO

   ! RANDOM NUMBER GENERATION AND DETERMINATION OF NUMBER OF NEWBORN CLOUDS BY DRAW FROM
   ! POISSON DISTRIBUTION
   ! Separate loop for random_Poisson call because it doesn't vectorise on NEC
   
   ! Loop over grid points
   DO i = i_startidx, i_endidx


      ! Initialise diagnostic fields that keep track of how much mass flux is added by newborn clouds,
      ! and how much is removed by dying clouds
      mf_new_a(i)=0._WP
      mf_die_a(i)=0._WP
      mf_new_p(i)=0._WP
      mf_die_p(i)=0._WP

      ! specify grid cell area (must be repeated because it's grid point dependent, and we're in a new loop)
      dxy     = cell_area(i)
      ! inverse of grid cell area
      rdxy    = 1._WP/dxy

      ! Only consider grid cells with active shallow convection
      ! If the grayzone tuning is used (not recommended with stochastic scheme)
      ! ktype=1 (deep) will also be used.
      IF (ktype(i) == 2 .or. (lgrayzone .and. ktype(i) == 1)) THEN  

        ! The random seed for each grid point is calculated based on lat, lon, forecast time and ensemble number,
        ! such that the seed is reproducable for subsequent runs. NOTE: the seed is not updated in this routine!
        iseed = lseed(i)

        ! Get sufficient random numbers for four calls to the random_Poisson routine. This routine iterates, and
        ! 50 random numbers per call is a very conservative estimate of the random numbers needed.
        streammax=200
        ! Initialise the random number generator
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
            &                                  nmaxstreams=streammax)
        ! Retrieve streammax new random numbers to use in draw from Poisson distributions
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        ! Initial total grid cell mass flux is sum of active/passive MF at previous time step
        tempmf=mfp(i)+mfa(i)

#ifdef HAVE_ACM_LICENSE           
        ! Determine number of newborn active clouds by drawing from Poisson distribution with given birth rate.
        idx=1 ! This index keeps track of which random numbers out of the 200 have already been used
        rn_poisson1 = random_Poisson(birth_rate_a(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        
        ! Determine number of dying active clouds by drawing from Poisson distribution with given death rate.
        idx=50 ! Start at index 50, to make sure to use "fresh" random numbers
        rn_poisson2 = random_Poisson(death_rate_a(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        
        ! Determine number of newborn active clouds by drawing from Poisson distribution with given birth rate.
        idx=100 ! Start at index 100, to make sure to use "fresh" random numbers
        rn_poisson3 = random_Poisson(birth_rate_p(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        
        ! Determine number of dying passive clouds by drawing from Poisson distribution with given death rate.
        idx=150 ! Start at index 150, to make sure to use "fresh" random numbers
        rn_poisson4 = random_Poisson(death_rate_p(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        idx=200
#else
        ! Determine number of newborn active clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given birth rate.
        idx=1 ! This index keeps track of which random numbers out of the 200 have already been used
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson1 = MAX(0, INT(z0 * SQRT(birth_rate_a(i)*ptsphy) + birth_rate_a(i)*ptsphy))
        
        ! Determine number of dying active clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given death rate.
        idx=50 
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson2 = MAX(0, INT(z0 * SQRT(death_rate_a(i)*ptsphy) + death_rate_a(i)*ptsphy))
        
        ! Determine number of newborn passive clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given birth rate.
        idx=100 ! This index keeps track of which random numbers out of the 200 have already been used
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson3 = MAX(0, INT(z0 * SQRT(birth_rate_p(i)*ptsphy) + birth_rate_p(i)*ptsphy))
        
        ! Determine number of dying passive clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given death rate.
        idx=150 
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson4 = MAX(0, INT(z0 * SQRT(death_rate_p(i)*ptsphy) + death_rate_p(i)*ptsphy))
        idx=200
#endif        
        
        ! GENERATE RANDOM NUMBERS, AND DRAW EACH NEW CLOUD'S MASS FLUX FROM
        ! WEIBULL DISTRIBUTION

        ! Get a random number for each newly born/dying cloud, plus 200 extra
        ! so we can throw out the first 200 that were already used for the Poisson draws.
        streammax=rn_poisson1+rn_poisson2+rn_poisson3+rn_poisson4+idx
        
        ! Safety check - we can draw only 5120 random numbers at a time. This
        ! limit is hard-coded into the random number generator.
        ! For resolutions up to 5km, this limit should never be reached, but in 
        ! case this code is run at very coarse resolutions, this will make sure
        ! the number is capped at the limit. Note: As an added safety feature,
        ! lstoch_sde is set to .false. for resolutions above 20km in the physics
        ! setup.
        ! Reduce cloud numbers equally in all categories of active/passive/born/dying clouds.
        IF (streammax > 5120) THEN
           excess=streammax/5120._WP-1._WP
           rn_poisson3=rn_poisson3-CEILING(excess*(rn_poisson3+idx*.25))
           rn_poisson4=rn_poisson4-CEILING(excess*(rn_poisson4+idx*.25))
           rn_poisson1=rn_poisson1-CEILING(excess*(rn_poisson1+idx*.25))
           rn_poisson2=rn_poisson2-CEILING(excess*(rn_poisson2+idx*.25))
           streammax=rn_poisson1+rn_poisson2+rn_poisson3+rn_poisson4+idx
        ENDIF
        ! Initialize and retrieve only as many random numbers as will be needed - speeds up code
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
             &                                  nmaxstreams=streammax)
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        kstart=idx+1 ! Start using first random number at 201
        kstop=idx+rn_poisson1
        DO k = kstart,kstop
           ! Randomly draw mass flux from Weibull distribution for active clouds
           ! The cloud's mass flux is given by Eqn 3 Sakradzija and Klocke, 2018.
           tempmf = tempmf + (-LOG(1.-rn_u(k))*(lambda2(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux added in diagnostic
           mf_new_a(i)=mf_new_a(i)+(-LOG(1.-rn_u(k))*(lambda2(i)**k_wei))**kinv*rdxy
        END DO

        kstart=kstop+1
        kstop=kstop+rn_poisson2
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_a
           tempmf = tempmf  - (-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux added in diagnostic
           mf_die_a(i)=mf_die_a(i)+(-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
        END DO
        
        ! Repeat for passive clouds
        kstart=kstop+1
        kstop=kstop+rn_poisson3
        DO k =  kstart,kstop
           ! Randomly draw mass flux from Weibull distribution for passive clouds
           ! The cloud's mass flux is given by Eqn 3 Sakradzija and Klocke, 2018.
           tempmf = tempmf + (-LOG(1.-rn_u(k))*(lambda1**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux lost in diagnostic
           mf_new_p(i)=mf_new_p(i)+(-LOG(1.-rn_u(k))*(lambda1**k_wei))**kinv*rdxy
        END DO

        kstart=kstop+1
        kstop=kstop+rn_poisson4
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_p
           tempmf = tempmf  - (-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux lost in diagnostic
           mf_die_p(i)=mf_die_p(i)+(-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
        END DO

        IF (luse3d) THEN 
          ! write diagnostics
          extra_3d(i,1,2)=birth_rate_p(i)*ptsphy        ! passive birth rate (in units of clouds per time step)
          extra_3d(i,2,2)=birth_rate_a(i)*ptsphy        ! active birth rate (in units of clouds per time step)
          extra_3d(i,3,2)=clnum_p(i)+float(rn_poisson3-rn_poisson4)! current number of passive clouds (number)
          extra_3d(i,4,2)=clnum_a(i)+float(rn_poisson1-rn_poisson2)! current number of active clouds (number)
          extra_3d(i,5,2)=float(rn_poisson3)            ! newborn passive clouds (number)
          extra_3d(i,6,2)=float(rn_poisson4)            ! dying   passive clouds (number)
          extra_3d(i,7,2)=float(rn_poisson1)            ! newborn active clouds (number)
          extra_3d(i,8,2)=float(rn_poisson2)            ! dying   active clouds (number)
          extra_3d(i,9,2)=clnum_a(i)+clnum_p(i)+float(rn_poisson1+rn_poisson3-rn_poisson2-rn_poisson4) ! total number of clouds (active+passive)
          extra_3d(i,10,2)=tempmf                       ! total mass flux (per unit area)
          extra_3d(i,11,2)=mf_new_p(i)                  ! MF of newborn passive clouds
          extra_3d(i,12,2)=mf_die_p(i)                  ! MF of dying   passive clouds
          extra_3d(i,13,2)=mf_new_a(i)                  ! MF of newborn active clouds
          extra_3d(i,14,2)=mf_die_a(i)                  ! MF of dying   active clouds
          extra_3d(i,15,2)=lambda1                      ! Weibull parameter passiv clouds
          extra_3d(i,16,2)=lambda2(i)                   ! Weibull parameter active clouds
          extra_3d(i,17,2)=mean_m_p(i)                  ! Expected value of Weibull dist. of current passive cloud ensemble
          extra_3d(i,18,2)=mean_m_a(i)                  ! Expected value of Weibull dist. of current active  cloud ensemble
          extra_3d(i,19,2)=death_rate_p(i)*ptsphy       ! passive death rate (in units of clouds per time step)
          extra_3d(i,20,2)=death_rate_a(i)*ptsphy       ! active death rate (in units of clouds per time step)
        ENDIF 
      ELSE !ktype!=2
        ! If shallow convection is not active, the cloud ensemble still continues to decay in the background.
         
        ! The random seed for each grid point is calculated based on lat, lon, forecast time and ensemble number,
        ! such that the seed is reproducable for subsequent runs. NOTE: the seed is not updated in this routine!
        iseed=lseed(i)

        ! Get sufficient random numbers for four calls to the random_Poisson routine. This routine iterates, and
        ! 50 random numbers per call is a very conservative estimate of the random numbers needed.
        streammax=200
         ! Initialise the random number generator
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
            &                                  nmaxstreams=streammax)
        ! Retrieve streammax new random numbers to use in draw from Poisson distributions
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        ! Initial grid cell mass flux is sum of active/passive MF at previous time step
        tempmf=mfp(i)+mfa(i)

#ifdef HAVE_ACM_LICENSE
        ! Determine number of dying active clouds by drawing from Poisson distribution with given death rate.
        idx=1! This index keeps track of which random numbers out of the 200 have already been used
        rn_poisson2 = random_Poisson(death_rate_a(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        ! Determine number of dying passive clouds by drawing from Poisson distribution with given death rate.
        idx=50! Start at index 50, to make sure to use "fresh" random numbers
        rn_poisson4 = random_Poisson(death_rate_p(i)*ptsphy,idx,streammax,rn_u(1:streammax))
        idx=200
#else
        ! Determine number of dying active clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given death rate.
        idx=0 
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson2 = MAX(0, INT(z0 * SQRT(death_rate_a(i)*ptsphy) + death_rate_a(i)*ptsphy))
        
        ! Determine number of dying passive clouds by sampling a normal distribution
        ! (instead of Poisson) using the Box-Muller method, with given death rate.
        idx=50 
        z0 = SQRT(-2._wp * LOG(rn_u(idx))) * COS(pi * rn_u(idx+25))
        rn_poisson4 = MAX(0, INT(z0 * SQRT(death_rate_p(i)*ptsphy) + death_rate_p(i)*ptsphy))
        idx=200
#endif

        ! Get a random number for each newly born/dying cloud, plus 200 extra
        ! so we can throw out the first 200 that were already used for the Poisson draws.
        streammax=rn_poisson2+rn_poisson4+idx

        ! Safety check - we can draw only 5120 random numbers at a time. This
        ! limit is hard-coded into the random number generator.
        ! For resolutions up to 5km, this limit should never be reached, but in 
        ! case this code is run at very coarse resolutions, this will make sure
        ! the number is capped at the limit. Note: As an added safety feature,
        ! lstoch_sde is set to .false. for resolutions above 20km in the physics
        ! setup.
        ! Reduce cloud numbers equally in all categories of active/passive/born/dying clouds.
        IF (streammax > 5120) THEN
           excess=streammax/5120._WP-1._WP
           rn_poisson4=rn_poisson4-CEILING(excess*(rn_poisson4+idx*.5))
           rn_poisson2=rn_poisson2-CEILING(excess*(rn_poisson2+idx*.5))
           streammax=rn_poisson2+rn_poisson4+idx
        ENDIF
        ! Initialize and retrieve only as many random numbers as will be needed - speeds up code
        CALL random_number_generator%initialize(IRngMinstdVector, iseed=iseed, &
             &                                  nmaxstreams=streammax)
        CALL random_number_generator%uniform_distribution(rn_u(1:streammax))

        kstart=idx+1
        kstop=idx+rn_poisson2
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_a
           mean_m_a(i) = mfa(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(clnum_a(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           tempmf = tempmf  - (-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
           ! Keep track of active mass flux lost in diagnostic
           mf_die_a(i)=mf_die_a(i)+(-LOG(1.-rn_u(k))*(mean_m_a(i)**k_wei))**kinv*rdxy
        END DO

        kstart=kstop+1
        kstop=kstop+rn_poisson4
        DO k = kstart,kstop
           ! To determine the mass flux of the dying clouds, draw from Weibull distribution
           ! with expected value mean_m_p
           mean_m_p(i) = mfp(i)*dxy*gamma(1.+beta_mf*kinv)/MAX(clnum_p(i)*gamma(1.+(beta_mf+1)*kinv), 1.E-10_wp)
           tempmf = tempmf  - (-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
           ! Keep track of passive mass flux lost in diagnostic
           mf_die_p(i)=mf_die_p(i)+(-LOG(1.-rn_u(k))*(mean_m_p(i)**k_wei))**kinv*rdxy
        END DO

        IF (luse3d) THEN 
          ! Write diagnostics into extra variables
          extra_3d(i,1,2)=0.                            ! passive birth rate (in units of clouds per time step)
          extra_3d(i,2,2)=0.                            ! active birth rate (in units of clouds per time step)
          extra_3d(i,3,2)=clnum_p(i)+float(rn_poisson4) ! current number of prognostic passive clouds (number)
          extra_3d(i,4,2)=clnum_a(i)+float(rn_poisson2) ! current number of prognostic active clouds (number)
          extra_3d(i,5,2)=0.                            ! newborn passive clouds (number)
          extra_3d(i,6,2)=float(rn_poisson4)            ! dying   passive clouds (number)
          extra_3d(i,7,2)=0.                            ! newborn active clouds (number)
          extra_3d(i,8,2)=float(rn_poisson2)            ! dying   active clouds (number)
          extra_3d(i,9,2)=clnum_a(i)+clnum_p(i)+float(-rn_poisson2-rn_poisson4) ! total number of clouds (active+passive)
          extra_3d(i,10,2)=tempmf                       ! total mass flux (per unit area)
          extra_3d(i,11,2)=0.                           ! mf of newborn passive clouds
          extra_3d(i,12,2)=mf_die_p(i)                  ! mf of dying   passive clouds
          extra_3d(i,13,2)=0.                           ! mf of newborn active clouds
          extra_3d(i,14,2)=mf_die_a(i)                  ! mf of dying   active clouds
          extra_3d(i,15,2)=0.                           ! Weibull parameter passiv clouds
          extra_3d(i,16,2)=0.                           ! Weibull parameter active clouds
          extra_3d(i,17,2)=mean_m_p(i)                  ! Expected value of Weibull dist. of current passive cloud ensemble
          extra_3d(i,18,2)=mean_m_a(i)                  ! Expected value of Weibull dist. of current active  cloud ensemble
          extra_3d(i,19,2)=death_rate_p(i)*ptsphy       ! passive death rate (in units of clouds per time step)
          extra_3d(i,20,2)=death_rate_a(i)*ptsphy       ! active death rate (in units of clouds per time step)
        ENDIF 
      ENDIF
    ENDDO

  END SUBROUTINE shallow_stoch_sde_passive

END MODULE mo_stoch_sde
