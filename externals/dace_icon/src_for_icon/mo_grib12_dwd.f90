!
!+ DWD GRIB_API parameter tables for translation from GRIB1 to GRIB2
!
! $Id$
!
MODULE mo_grib12_dwd
!
! Description:
!   GRIB_API parameter tables and parameter translation routines
!   for the conversion from GRIB1 to GRIB2.
!   The actual parameter definitions are included from a file
!   generated by the tool extract_shortnames.awk .
!
! Current Code Owner: DWD, Harald Anlauf
!    phone: +49 69 8062 4941
!    fax:   +49 69 8062 3721
!    email: harald.anlauf@dwd.de
!
! History:
! Version      Date       Name
! ------------ ---------- ----
! V1_23        2013-03-26 Harald Anlauf
!  Initial version for GRIB_API prerelease-1.9.18-1
! V1_28        2014/02/26 Harald Anlauf
!  Fixes for LETKF; GRIB_API, GRIB1 and GRIB2 handling of T_S/T_SO
! V1_47        2016-06-06 Harald Anlauf
!  Split localdefs{1,2} from shortnames_grib{1,2}.incf
!
! Code Description:
! Language: Fortran 95.
! Software Standards:
!
!------------------------------------------------------------------------------
  !-------------
  ! Modules used
  !-------------
  use mo_exception,   only: finish              ! abort on error condition
  implicit none

  !----------------
  ! Public entities
  !----------------
  private
  public :: search_grib1         ! Search parameter in GRIB1 table
  public :: search_grib2         ! Search parameter in GRIB2 table
  public :: setup_tables_grib12  ! Set up GRIB1/2 tables
  public :: delete_tables_grib12 ! deallocate GRIB1/2 tables
  public :: t_par_grib1          ! Derived type for GRIB1 parameters
  public :: t_par_grib2          ! Derived type for GRIB2 parameters
  public :: empty2               ! Empty entry with GRIB2 parameters

  !----------------------------------------------------
  ! Derived type holding essential DWD GRIB1 parameters
  !----------------------------------------------------
  type t_par_grib1
     integer            :: paramID         ! Unique Parameter ID
     integer            :: table           ! grib1 table number
     integer            :: code            ! grib1 element code
     integer            :: levtyp          ! leveltype
     integer            :: level           ! level
     integer            :: levtop          ! top of layer
     integer            :: levbot          ! bottom of layer
     integer            :: range           ! time range indicator
     character(len=16)  :: shortname       ! postprocessing name
     character(len=100) :: longname        ! verbose description
  end type t_par_grib1

  !------------------------------------------------------------
  ! Empty table entry.
  ! Note: the value -1 represents "undefined" as well as "any".
  !------------------------------------------------------------
  type(t_par_grib1), parameter :: empty1 = &
       t_par_grib1(-1,-1,-1,-1,-1,-1,-1,-1,"","")

  !----------------------------------------------------
  ! Derived type holding essential DWD GRIB2 parameters
  !----------------------------------------------------
  type t_par_grib2
     integer            :: paramID         ! Unique Parameter ID
     integer            :: discipline      ! GRIB2 discipline
     integer            :: category        ! GRIB2 parameterCategory
     integer            :: number          ! GRIB2 parameterNumber
     integer            :: gridnum         ! numberOfGridInReference
     integer            :: T_FFS           ! typeOfFirstFixedSurface
     integer            :: SF_FFS          ! scaleFactorOfFirstFixedSurface
     integer            :: SV_FFS          ! scaledValueOfFirstFixedSurface
     integer            :: T_SFS           ! typeOfSecondFixedSurface
     integer            :: SF_SFS          ! scaleFactorOfSecondFixedSurface
     integer            :: SV_SFS          ! scaledValueOfSecondFixedSurface
     integer            :: T_GenP          ! typeOfGeneratingProcess
     integer            :: T_StatP         ! typeOfStatisticalProcessing
     integer            :: cTyp            ! constituentType
     integer            :: modNum          ! modeNumber
     character(len=16)  :: shortname       ! postprocessing name
     character(len=100) :: longname        ! verbose description
  end type t_par_grib2

  !------------------------------------------------------------
  ! Empty table entry.
  ! Note: the value -1 represents "undefined" as well as "any".
  !------------------------------------------------------------
  type(t_par_grib2), parameter :: empty2 = &
       t_par_grib2(-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,"","")

  !------------------------------
  ! Tables for GRIB1/2 parameters
  !------------------------------
  type(t_par_grib1), allocatable, target :: dwd_grib1tab(:)
  type(t_par_grib2), allocatable, target :: dwd_grib2tab(:)

!------------------------------------------------------------------------------
contains
!------------------------------------------------------------------------------
  !-------------------------------------------------------------------
  ! Routine to search in the GRIB1 table
  ! The first entry matching the optional parameter values is returned
  !-------------------------------------------------------------------
  function search_grib1 (paramID, name, code, table, levtyp, level) &
           result (entry)
    type(t_par_grib1)                     :: entry   ! returned table entry
    integer         ,intent(in) ,optional :: paramID ! parameter ID
    character(len=*),intent(in) ,optional :: name    ! postprocessing name
    integer         ,intent(in) ,optional :: code    ! code  number to search
    integer         ,intent(in) ,optional :: table   ! table number to search
    integer         ,intent(in) ,optional :: levtyp  ! level type   to search
    integer         ,intent(in) ,optional :: level   ! level value  to search

    integer :: i
    if (.not.allocated(dwd_grib1tab)) call init_dwd_grib1tab ()
    do i = 1, size (dwd_grib1tab)
      if   (present(paramID)) then
        if (paramID /= dwd_grib1tab(i)% paramID)   cycle
      endif
      if   (present(code)) then
        if (code    /= dwd_grib1tab(i)% code)      cycle
      endif
      if   (present(table)) then
        if (table   /= dwd_grib1tab(i)% table)     cycle
      endif
      if   (present(levtyp)) then
        if (levtyp  /= dwd_grib1tab(i)% levtyp)    cycle
      endif
      if   (present(level)) then
        if (level   /= dwd_grib1tab(i)% level .and.    &
             -1     /= dwd_grib1tab(i)% level)     cycle
      endif
      if   (present(name)) then
        if (name    /= dwd_grib1tab(i)% shortname) cycle
      endif
      entry = dwd_grib1tab(i)
      return
    end do
    entry = empty1
  end function search_grib1
  !----------------------------------------------------------------------------
  !-------------------------------------------------------------------
  ! Routine to search in the GRIB2 table
  ! The first entry matching the optional parameter values is returned
  !-------------------------------------------------------------------
  function search_grib2 (paramID, name, dis, cat, num, &
                         gridnum, levtyp1, levtyp2     ) result (entry)
    type(t_par_grib2)                     :: entry   ! returned table entry
    integer         ,intent(in) ,optional :: paramID ! parameter ID
    character(len=*),intent(in) ,optional :: name    ! postprocessing name
    integer         ,intent(in) ,optional :: dis     ! discipline
    integer         ,intent(in) ,optional :: cat     ! parameterCategory
    integer         ,intent(in) ,optional :: num     ! parameterNumber
    integer         ,intent(in) ,optional :: gridnum ! numberOfGridInReference
    integer         ,intent(in) ,optional :: levtyp1 ! level type (FFS)
    integer         ,intent(in) ,optional :: levtyp2 ! level type (SFS)

    integer :: i
    if (.not.allocated(dwd_grib2tab)) call init_dwd_grib2tab ()
    entry = empty2
    do i = 1, size (dwd_grib2tab)
      if   (present(paramID)) then
        if (paramID /= dwd_grib2tab(i)% paramID)    cycle
      endif
      if   (present(dis)) then
        if (dis     /= dwd_grib2tab(i)% discipline) cycle
      endif
      if   (present(cat)) then
        if (cat     /= dwd_grib2tab(i)% category)   cycle
      endif
      if   (present(num)) then
        if (num     /= dwd_grib2tab(i)% number)     cycle
      endif
      if   (present(gridnum)) then
        if (gridnum /= dwd_grib2tab(i)% gridnum)    cycle
      endif
      if   (present(levtyp1)) then
        if (levtyp1 /= dwd_grib2tab(i)% T_FFS)      cycle
      endif
      if   (present(levtyp2)) then
        if (levtyp2 /= dwd_grib2tab(i)% T_SFS)      cycle
      endif
      if   (present(name)) then
        if (name    /= dwd_grib2tab(i)% shortname)  cycle
      endif
      entry = dwd_grib2tab(i)
      !------------------------------------------
      ! Check for duplicate entries of given name
      ! (prefer WMO definition over local one)
      !------------------------------------------
      if (present (name) .and. .not. present (paramId) .and.  &
           any ( [ entry% discipline, entry% category, entry% number ] >= 192)) then
        if (entry% discipline >= 192 .and. present (dis))  exit
        if (entry% category   >= 192 .and. present (cat))  exit
        if (entry% number     >= 192 .and. present (num))  exit
        cycle
      else
        exit
      end if
    end do
  end function search_grib2
  !----------------------------------------------------------------------------
  subroutine setup_tables_grib12 ()
    if (.not.allocated(dwd_grib1tab)) call init_dwd_grib1tab ()
    if (.not.allocated(dwd_grib2tab)) call init_dwd_grib2tab ()
  end subroutine setup_tables_grib12
  !----------------------------------------------------------------------------
  subroutine delete_tables_grib12 ()
    if (allocated(dwd_grib1tab)) deallocate (dwd_grib1tab)
    if (allocated(dwd_grib2tab)) deallocate (dwd_grib2tab)
  end subroutine delete_tables_grib12
  !----------------------------------------------------------------------------
!==============================================================================
  subroutine init_dwd_grib1tab ()
    !----------------
    ! Local variables
    !----------------
    integer                    :: k, n

    call alloc_grib1tab ()
    call init_grib1tab ()
    !---
  contains
    !---
    subroutine init_grib1tab ()
!========================
#undef  TABSIZE
#undef  TABSIZE_LOCAL
#undef  PARAM
#undef  PDESC
#define PARAM call addpar
#define PDESC call adddes
#include "shortnames_grib1.incf"
#include "localdefs_grib1.incf"
!========================
    end subroutine init_grib1tab
    !---
    subroutine alloc_grib1tab ()
      if (allocated (dwd_grib1tab)) deallocate (dwd_grib1tab)
      k = 0
      n = TABSIZE
#ifdef TABSIZE_LOCAL
      n = n + TABSIZE_LOCAL
#endif
      allocate (dwd_grib1tab(n))
      dwd_grib1tab = empty1
    end subroutine alloc_grib1tab
    !---
    subroutine addpar (paramID, shortname, longname, table, code, leveltype,  &
               level, topLevel, bottomLevel, range, localElementNumber, insert)
      integer,                    intent(in) :: paramID
      character(len=*),           intent(in) :: shortname
      character(len=*), optional, intent(in) :: longname
      integer,                    intent(in) :: table
      integer,                    intent(in) :: code
      integer,          optional, intent(in) :: leveltype
      integer,          optional, intent(in) :: level
      integer,          optional, intent(in) :: toplevel
      integer,          optional, intent(in) :: bottomlevel
      integer,          optional, intent(in) :: range
      integer,          optional, intent(in) :: localElementNumber  ! Ignored
      logical,          optional, intent(in) :: insert

      type(t_par_grib1), pointer :: t
      logical                    :: append
      integer                    :: l
      !-----------------------------------------------
      ! Scan for existing entry;
      ! we require ascending order and unique paramIDs
      !-----------------------------------------------
      append = .true.; if (present (insert)) append = .not.insert
      if (k == 0) then
        k = 1
        t => dwd_grib1tab(k)
      else
        k = k + 1
        if (k>n) call finish ("init_dwd_grib1tab","table overflow!")
        if (paramID > dwd_grib1tab(k-1)% paramID) then
          t => dwd_grib1tab(k)
        else
          if (append) then
            call finish ("init_dwd_grib1tab","entries not ascending or unique!")
          else
            do l = k, 1, -1
              if (l==1) then
                t => dwd_grib1tab(1)
              else if (paramID < dwd_grib1tab(l-1)% paramID) then
                dwd_grib1tab(l) = dwd_grib1tab(l-1)
              else if (paramID == dwd_grib1tab(l-1)% paramID) then
                call finish ("init_dwd_grib1tab","entry to insert not unique!")
              else
                t => dwd_grib1tab(l)
                exit
              endif
            end do
          endif
        end if
      end if
      t% paramID   = paramID
      t% shortname = shortname
      t% table     = table
      t% code      = code
      if (present (leveltype))   t% levtyp   = leveltype
      if (present (level))       t% level    = level
      if (present (toplevel))    t% levtop   = toplevel
      if (present (bottomlevel)) t% levbot   = bottomlevel
      if (present (range))       t% range    = range
      if (present (longname))    t% longname = longname
    end subroutine addpar
    !---
    subroutine adddes (paramID, longname)
      integer,          intent(in) :: paramID
      character(len=*), intent(in) :: longname

      type(t_par_grib1), pointer :: t
      !----------------------------
      ! Scan for existing entry;
      ! we require ascending order.
      !----------------------------
      if (k == 0) then
         k = 1
      else
         if      (paramID <  dwd_grib1tab(k)% paramID) then
            call finish ("init_dwd_grib1tab","entries not ascending!")
         else if (paramID >  dwd_grib1tab(k)% paramID) then
            k = k + 1              ! Extend table
         end if
      end if
      if (k>n) call finish ("init_dwd_grib1tab","table overflow!")
      t => dwd_grib1tab(k)
      t% paramID  = paramID
      t% longname = longname
    end subroutine adddes
  end subroutine init_dwd_grib1tab
!==============================================================================
  subroutine init_dwd_grib2tab ()
    !----------------
    ! Local variables
    !----------------
    integer                    :: k, n

    call alloc_grib2tab ()
    call init_grib2tab ()
    !---
  contains
    !---
    subroutine init_grib2tab ()
!========================
#undef  TABSIZE
#undef  TABSIZE_LOCAL
#undef  PARAM
#undef  PDESC
#define PARAM call addpar
#define PDESC call adddes
#include "shortnames_grib2.incf"
#include "localdefs_grib2.incf"
!========================
    end subroutine init_grib2tab
    !---
    subroutine alloc_grib2tab ()
      if (allocated (dwd_grib2tab)) deallocate (dwd_grib2tab)
      k = 0
      n = TABSIZE
#ifdef TABSIZE_LOCAL
      n = n + TABSIZE_LOCAL
#endif
      allocate (dwd_grib2tab(n))
      dwd_grib2tab = empty2
    end subroutine alloc_grib2tab
    !---
    subroutine addpar (paramID, shortname, longname, &
                       dis, cat, num, gridnum,       &
                       T_FFS, SF_FFS, SV_FFS,        &
                       T_SFS, SF_SFS, SV_SFS,        &
                       T_GenP, T_StatP, cTyp, modNum )
      integer,         intent(in) :: paramID
      character(len=*),intent(in) :: shortname
      character(len=*), &
              optional,intent(in) :: longname
      integer,         intent(in) :: dis      ! discipline
      integer,         intent(in) :: cat      ! parameterCategory
      integer,         intent(in) :: num      ! parameterNumber
      integer,optional,intent(in) :: gridnum  ! numberOfGridInReference
      integer,optional,intent(in) :: T_FFS    ! typeOfFirstFixedSurface
      integer,optional,intent(in) :: SF_FFS   ! scaleFactorOfFirstFixedSurface
      integer,optional,intent(in) :: SV_FFS   ! scaledValueOfFirstFixedSurface
      integer,optional,intent(in) :: T_SFS    ! typeOfSecondFixedSurface
      integer,optional,intent(in) :: SF_SFS   ! scaleFactorOfSecondFixedSurface
      integer,optional,intent(in) :: SV_SFS   ! scaledValueOfSecondFixedSurface
      integer,optional,intent(in) :: T_GenP   ! typeOfGeneratingProcess
      integer,optional,intent(in) :: T_StatP  ! typeOfStatisticalProcessing
      integer,optional,intent(in) :: cTyp     ! constituentType
      integer,optional,intent(in) :: modNum   ! modeNumber

      type(t_par_grib2), pointer :: t
      !----------------------------
      ! Scan for existing entry;
      ! we require ascending order.
      !----------------------------
      if (k == 0) then
         k = 1
      else
         if      (paramID <  dwd_grib2tab(k)% paramID) then
            write (0,*) "paramID < dwd_grib2tab(k)% paramID (addpar)", &
                 paramID,dwd_grib2tab(k)% paramID
            call finish ("init_dwd_grib2tab","entries not ascending!")
         else if (paramID >  dwd_grib2tab(k)% paramID) then
            k = k + 1              ! Extend table
         end if
      end if
      if (k>n) call finish ("init_dwd_grib2tab","table overflow!")
      t => dwd_grib2tab(k)
      t% paramID   = paramID
      t% shortname = shortname
      t% discipline  = dis
      t% category    = cat
      t% number       = num
      if(present(gridnum))  t% gridnum = gridnum ! numberOfGridInReference
      if(present(T_FFS  ))  t% T_FFS   = T_FFS   ! typeOfFirstFixedSurf.
      if(present(SF_FFS ))  t% SF_FFS  = SF_FFS  ! scaleFactorOfFirstFixedSurf.
      if(present(SV_FFS ))  t% SV_FFS  = SV_FFS  ! scaledValueOfFirstFixedSurf.
      if(present(T_SFS  ))  t% T_SFS   = T_SFS   ! typeOfSecondFixedSurf.
      if(present(SF_SFS ))  t% SF_SFS  = SF_SFS  ! scaleFactorOfSecondFixedSurf.
      if(present(SV_SFS ))  t% SV_SFS  = SV_SFS  ! scaledValueOfSecondFixedSurf.
      if(present(T_GenP ))  t% T_GenP  = T_GenP  ! typeOfGeneratingProcess
      if(present(T_StatP))  t% T_StatP = T_StatP ! typeOfStatisticalProcessing
      if(present(cTyp   ))  t% cTyp    = cTyp    ! constituentType
      if(present(modNum ))  t% modNum  = modNum  ! modeNumber
      if(present(longname)) t% longname= longname
    end subroutine addpar
    !---
    subroutine adddes (paramID, longname)
      integer,          intent(in) :: paramID
      character(len=*), intent(in) :: longname

      type(t_par_grib2), pointer :: t
      !----------------------------
      ! Scan for existing entry;
      ! we require ascending order.
      !----------------------------
      if (k == 0) then
         k = 1
      else
         if      (paramID <  dwd_grib2tab(k)% paramID) then
            write (0,*) "paramID < dwd_grib2tab(k)% paramID (adddes)", &
                 paramID,dwd_grib2tab(k)% paramID
            call finish ("init_dwd_grib2tab","entries not ascending!")
         else if (paramID >  dwd_grib2tab(k)% paramID) then
            k = k + 1              ! Extend table
         end if
      end if
      if (k>n) call finish ("init_dwd_grib2tab","table overflow!")
      t => dwd_grib2tab(k)
      t% paramID  = paramID
      t% longname = longname
    end subroutine adddes
  end subroutine init_dwd_grib2tab
!==============================================================================
end module mo_grib12_dwd
