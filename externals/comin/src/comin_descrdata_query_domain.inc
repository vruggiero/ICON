!  @authors 11/2023 :: ICON Community Interface  <comin@icon-model.org>
!
!  SPDX-License-Identifier: BSD-3-Clause
!
!  Please see the file LICENSE in the root of the source tree for this code.
!  Where software is supplied by third parties, it is indicated in the
!  headers of the routines.

! *** DO NOT EDIT MANUALLY!  Generated by python script in utils/. DO NOT EDIT MANUALLY! *** !

  SUBROUTINE comin_descrdata_get_domain_grid_filename(jg, grid_filename, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_grid_filename")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: grid_filename
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%grid_filename)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      &  "ERROR: Pointer of grid_filename not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%grid_filename)
    grid_filename = C_LOC(p%grid_filename)
  END SUBROUTINE comin_descrdata_get_domain_grid_filename

  SUBROUTINE comin_descrdata_get_domain_grid_uuid(jg, grid_uuid, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_grid_uuid")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: grid_uuid
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%grid_uuid)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      &  "ERROR: Pointer of grid_uuid not associated.")
    END IF
    arr_size = SHAPE(p%grid_uuid)
    grid_uuid = C_LOC(p%grid_uuid)
  END SUBROUTINE comin_descrdata_get_domain_grid_uuid

  SUBROUTINE comin_descrdata_get_domain_number_of_grid_used(jg, number_of_grid_used, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_number_of_grid_used")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: number_of_grid_used
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ALLOCATED(p%number_of_grid_used)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      &  "ERROR: Pointer of number_of_grid_used not associated.")
    END IF
    arr_size = SHAPE(p%number_of_grid_used)
    number_of_grid_used = C_LOC(p%number_of_grid_used)
  END SUBROUTINE comin_descrdata_get_domain_number_of_grid_used

  FUNCTION comin_descrdata_get_domain_id(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_id") &
      &  RESULT(id)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: id
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%id)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of id not associated.")
    END IF
    id  = p%id
  END FUNCTION comin_descrdata_get_domain_id

  FUNCTION comin_descrdata_get_domain_n_childdom(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_n_childdom") &
      &  RESULT(n_childdom)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: n_childdom
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%n_childdom)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of n_childdom not associated.")
    END IF
    n_childdom  = p%n_childdom
  END FUNCTION comin_descrdata_get_domain_n_childdom

  FUNCTION comin_descrdata_get_domain_dom_start(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_dom_start") &
      &  RESULT(dom_start)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    REAL(wp)                      :: dom_start
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of dom_start not associated.")
    END IF
    dom_start  = p%dom_start
  END FUNCTION comin_descrdata_get_domain_dom_start

  FUNCTION comin_descrdata_get_domain_dom_end(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_dom_end") &
      &  RESULT(dom_end)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    REAL(wp)                      :: dom_end
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of dom_end not associated.")
    END IF
    dom_end  = p%dom_end
  END FUNCTION comin_descrdata_get_domain_dom_end

  FUNCTION comin_descrdata_get_domain_nlev(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_nlev") &
      &  RESULT(nlev)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nlev
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%nlev)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of nlev not associated.")
    END IF
    nlev  = p%nlev
  END FUNCTION comin_descrdata_get_domain_nlev

  FUNCTION comin_descrdata_get_domain_nshift(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_nshift") &
      &  RESULT(nshift)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nshift
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%nshift)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of nshift not associated.")
    END IF
    nshift  = p%nshift
  END FUNCTION comin_descrdata_get_domain_nshift

  FUNCTION comin_descrdata_get_domain_nshift_total(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_nshift_total") &
      &  RESULT(nshift_total)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nshift_total
    !
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()

    p => comin_descrdata_get_domain(jg)
    IF (.NOT. ASSOCIATED(p%nshift_total)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain", &
      & "ERROR: Pointer of nshift_total not associated.")
    END IF
    nshift_total  = p%nshift_total
  END FUNCTION comin_descrdata_get_domain_nshift_total

  FUNCTION comin_descrdata_get_domain_cells(jg)
    USE iso_c_binding, ONLY: C_INT
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    TYPE(t_comin_descrdata_domain_cells), POINTER :: comin_descrdata_get_domain_cells

    p => comin_descrdata_get_domain(jg)
    comin_descrdata_get_domain_cells => p%cells
  END FUNCTION comin_descrdata_get_domain_cells

  FUNCTION comin_descrdata_get_domain_cells_ncells(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_ncells") &
      &  RESULT(ncells)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: ncells
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%ncells)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      & "ERROR: Pointer of ncells not associated.")
    END IF
    ncells  = p%ncells
  END FUNCTION comin_descrdata_get_domain_cells_ncells

  FUNCTION comin_descrdata_get_domain_cells_ncells_global(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_ncells_global") &
      &  RESULT(ncells_global)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: ncells_global
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%ncells_global)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      & "ERROR: Pointer of ncells_global not associated.")
    END IF
    ncells_global  = p%ncells_global
  END FUNCTION comin_descrdata_get_domain_cells_ncells_global

  FUNCTION comin_descrdata_get_domain_cells_nblks(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_nblks") &
      &  RESULT(nblks)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nblks
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%nblks)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      & "ERROR: Pointer of nblks not associated.")
    END IF
    nblks  = p%nblks
  END FUNCTION comin_descrdata_get_domain_cells_nblks

  FUNCTION comin_descrdata_get_domain_cells_max_connectivity(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_max_connectivity") &
      &  RESULT(max_connectivity)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: max_connectivity
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%max_connectivity)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      & "ERROR: Pointer of max_connectivity not associated.")
    END IF
    max_connectivity  = p%max_connectivity
  END FUNCTION comin_descrdata_get_domain_cells_max_connectivity

  SUBROUTINE comin_descrdata_get_domain_cells_num_edges(jg, num_edges, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_num_edges")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: num_edges
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%num_edges)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of num_edges not associated.")
    END IF
    arr_size = SHAPE(p%num_edges)
    num_edges = C_LOC(p%num_edges)
  END SUBROUTINE comin_descrdata_get_domain_cells_num_edges

  SUBROUTINE comin_descrdata_get_domain_cells_refin_ctrl(jg, refin_ctrl, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_refin_ctrl")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: refin_ctrl
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%refin_ctrl)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of refin_ctrl not associated.")
    END IF
    arr_size = SHAPE(p%refin_ctrl)
    refin_ctrl = C_LOC(p%refin_ctrl)
  END SUBROUTINE comin_descrdata_get_domain_cells_refin_ctrl

  SUBROUTINE comin_descrdata_get_domain_cells_start_index(jg, start_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_start_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%start_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of start_index not associated.")
    END IF
    arr_size = SHAPE(p%start_index)
    start_index = C_LOC(p%start_index)
  END SUBROUTINE comin_descrdata_get_domain_cells_start_index

  SUBROUTINE comin_descrdata_get_domain_cells_end_index(jg, end_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_end_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%end_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of end_index not associated.")
    END IF
    arr_size = SHAPE(p%end_index)
    end_index = C_LOC(p%end_index)
  END SUBROUTINE comin_descrdata_get_domain_cells_end_index

  SUBROUTINE comin_descrdata_get_domain_cells_start_block(jg, start_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_start_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%start_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of start_block not associated.")
    END IF
    arr_size = SHAPE(p%start_block)
    start_block = C_LOC(p%start_block)
  END SUBROUTINE comin_descrdata_get_domain_cells_start_block

  SUBROUTINE comin_descrdata_get_domain_cells_end_block(jg, end_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_end_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%end_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of end_block not associated.")
    END IF
    arr_size = SHAPE(p%end_block)
    end_block = C_LOC(p%end_block)
  END SUBROUTINE comin_descrdata_get_domain_cells_end_block

  SUBROUTINE comin_descrdata_get_domain_cells_child_id(jg, child_id, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_child_id")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_id
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%child_id)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of child_id not associated.")
    END IF
    arr_size = SHAPE(p%child_id)
    child_id = C_LOC(p%child_id)
  END SUBROUTINE comin_descrdata_get_domain_cells_child_id

  SUBROUTINE comin_descrdata_get_domain_cells_child_idx(jg, child_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_child_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%child_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of child_idx not associated.")
    END IF
    arr_size = SHAPE(p%child_idx)
    child_idx = C_LOC(p%child_idx)
  END SUBROUTINE comin_descrdata_get_domain_cells_child_idx

  SUBROUTINE comin_descrdata_get_domain_cells_child_blk(jg, child_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_child_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%child_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of child_blk not associated.")
    END IF
    arr_size = SHAPE(p%child_blk)
    child_blk = C_LOC(p%child_blk)
  END SUBROUTINE comin_descrdata_get_domain_cells_child_blk

  SUBROUTINE comin_descrdata_get_domain_cells_parent_glb_idx(jg, parent_glb_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_parent_glb_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: parent_glb_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%parent_glb_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of parent_glb_idx not associated.")
    END IF
    arr_size = SHAPE(p%parent_glb_idx)
    parent_glb_idx = C_LOC(p%parent_glb_idx)
  END SUBROUTINE comin_descrdata_get_domain_cells_parent_glb_idx

  SUBROUTINE comin_descrdata_get_domain_cells_parent_glb_blk(jg, parent_glb_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_parent_glb_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: parent_glb_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%parent_glb_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of parent_glb_blk not associated.")
    END IF
    arr_size = SHAPE(p%parent_glb_blk)
    parent_glb_blk = C_LOC(p%parent_glb_blk)
  END SUBROUTINE comin_descrdata_get_domain_cells_parent_glb_blk

  SUBROUTINE comin_descrdata_get_domain_cells_vertex_idx(jg, vertex_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_vertex_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vertex_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%vertex_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of vertex_idx not associated.")
    END IF
    arr_size = SHAPE(p%vertex_idx)
    vertex_idx = C_LOC(p%vertex_idx)
  END SUBROUTINE comin_descrdata_get_domain_cells_vertex_idx

  SUBROUTINE comin_descrdata_get_domain_cells_vertex_blk(jg, vertex_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_vertex_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vertex_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%vertex_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of vertex_blk not associated.")
    END IF
    arr_size = SHAPE(p%vertex_blk)
    vertex_blk = C_LOC(p%vertex_blk)
  END SUBROUTINE comin_descrdata_get_domain_cells_vertex_blk

  SUBROUTINE comin_descrdata_get_domain_cells_neighbor_blk(jg, neighbor_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_neighbor_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: neighbor_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%neighbor_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of neighbor_blk not associated.")
    END IF
    arr_size = SHAPE(p%neighbor_blk)
    neighbor_blk = C_LOC(p%neighbor_blk)
  END SUBROUTINE comin_descrdata_get_domain_cells_neighbor_blk

  SUBROUTINE comin_descrdata_get_domain_cells_neighbor_idx(jg, neighbor_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_neighbor_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: neighbor_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%neighbor_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of neighbor_idx not associated.")
    END IF
    arr_size = SHAPE(p%neighbor_idx)
    neighbor_idx = C_LOC(p%neighbor_idx)
  END SUBROUTINE comin_descrdata_get_domain_cells_neighbor_idx

  SUBROUTINE comin_descrdata_get_domain_cells_edge_idx(jg, edge_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_edge_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: edge_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%edge_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of edge_idx not associated.")
    END IF
    arr_size = SHAPE(p%edge_idx)
    edge_idx = C_LOC(p%edge_idx)
  END SUBROUTINE comin_descrdata_get_domain_cells_edge_idx

  SUBROUTINE comin_descrdata_get_domain_cells_edge_blk(jg, edge_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_edge_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: edge_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%edge_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of edge_blk not associated.")
    END IF
    arr_size = SHAPE(p%edge_blk)
    edge_blk = C_LOC(p%edge_blk)
  END SUBROUTINE comin_descrdata_get_domain_cells_edge_blk

  SUBROUTINE comin_descrdata_get_domain_cells_clon(jg, clon, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_clon")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: clon
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ALLOCATED(p%clon)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of clon not associated.")
    END IF
    arr_size = SHAPE(p%clon)
    clon = C_LOC(p%clon)
  END SUBROUTINE comin_descrdata_get_domain_cells_clon

  SUBROUTINE comin_descrdata_get_domain_cells_clat(jg, clat, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_clat")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: clat
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ALLOCATED(p%clat)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of clat not associated.")
    END IF
    arr_size = SHAPE(p%clat)
    clat = C_LOC(p%clat)
  END SUBROUTINE comin_descrdata_get_domain_cells_clat

  SUBROUTINE comin_descrdata_get_domain_cells_area(jg, area, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_area")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: area
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%area)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of area not associated.")
    END IF
    arr_size = SHAPE(p%area)
    area = C_LOC(p%area)
  END SUBROUTINE comin_descrdata_get_domain_cells_area

  SUBROUTINE comin_descrdata_get_domain_cells_hhl(jg, hhl, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_hhl")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: hhl
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ALLOCATED(p%hhl)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of hhl not associated.")
    END IF
    arr_size = SHAPE(p%hhl)
    hhl = C_LOC(p%hhl)
  END SUBROUTINE comin_descrdata_get_domain_cells_hhl

  SUBROUTINE comin_descrdata_get_domain_cells_glb_index(jg, glb_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_glb_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: glb_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%glb_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of glb_index not associated.")
    END IF
    arr_size = SHAPE(p%glb_index)
    glb_index = C_LOC(p%glb_index)
  END SUBROUTINE comin_descrdata_get_domain_cells_glb_index

  SUBROUTINE comin_descrdata_get_domain_cells_decomp_domain(jg, decomp_domain, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_cells_decomp_domain")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: decomp_domain
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_cells), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_cells(jg)
    IF (.NOT. ASSOCIATED(p%decomp_domain)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_cells", &
      &  "ERROR: Pointer of decomp_domain not associated.")
    END IF
    arr_size = SHAPE(p%decomp_domain)
    decomp_domain = C_LOC(p%decomp_domain)
  END SUBROUTINE comin_descrdata_get_domain_cells_decomp_domain

  FUNCTION comin_descrdata_get_domain_verts(jg)
    USE iso_c_binding, ONLY: C_INT
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    TYPE(t_comin_descrdata_domain_verts), POINTER :: comin_descrdata_get_domain_verts

    p => comin_descrdata_get_domain(jg)
    comin_descrdata_get_domain_verts => p%verts
  END FUNCTION comin_descrdata_get_domain_verts

  FUNCTION comin_descrdata_get_domain_verts_nverts(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_nverts") &
      &  RESULT(nverts)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nverts
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%nverts)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      & "ERROR: Pointer of nverts not associated.")
    END IF
    nverts  = p%nverts
  END FUNCTION comin_descrdata_get_domain_verts_nverts

  FUNCTION comin_descrdata_get_domain_verts_nverts_global(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_nverts_global") &
      &  RESULT(nverts_global)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nverts_global
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%nverts_global)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      & "ERROR: Pointer of nverts_global not associated.")
    END IF
    nverts_global  = p%nverts_global
  END FUNCTION comin_descrdata_get_domain_verts_nverts_global

  FUNCTION comin_descrdata_get_domain_verts_nblks(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_nblks") &
      &  RESULT(nblks)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nblks
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%nblks)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      & "ERROR: Pointer of nblks not associated.")
    END IF
    nblks  = p%nblks
  END FUNCTION comin_descrdata_get_domain_verts_nblks

  SUBROUTINE comin_descrdata_get_domain_verts_num_edges(jg, num_edges, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_num_edges")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: num_edges
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%num_edges)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of num_edges not associated.")
    END IF
    arr_size = SHAPE(p%num_edges)
    num_edges = C_LOC(p%num_edges)
  END SUBROUTINE comin_descrdata_get_domain_verts_num_edges

  SUBROUTINE comin_descrdata_get_domain_verts_refin_ctrl(jg, refin_ctrl, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_refin_ctrl")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: refin_ctrl
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%refin_ctrl)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of refin_ctrl not associated.")
    END IF
    arr_size = SHAPE(p%refin_ctrl)
    refin_ctrl = C_LOC(p%refin_ctrl)
  END SUBROUTINE comin_descrdata_get_domain_verts_refin_ctrl

  SUBROUTINE comin_descrdata_get_domain_verts_start_index(jg, start_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_start_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%start_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of start_index not associated.")
    END IF
    arr_size = SHAPE(p%start_index)
    start_index = C_LOC(p%start_index)
  END SUBROUTINE comin_descrdata_get_domain_verts_start_index

  SUBROUTINE comin_descrdata_get_domain_verts_end_index(jg, end_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_end_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%end_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of end_index not associated.")
    END IF
    arr_size = SHAPE(p%end_index)
    end_index = C_LOC(p%end_index)
  END SUBROUTINE comin_descrdata_get_domain_verts_end_index

  SUBROUTINE comin_descrdata_get_domain_verts_start_block(jg, start_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_start_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%start_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of start_block not associated.")
    END IF
    arr_size = SHAPE(p%start_block)
    start_block = C_LOC(p%start_block)
  END SUBROUTINE comin_descrdata_get_domain_verts_start_block

  SUBROUTINE comin_descrdata_get_domain_verts_end_block(jg, end_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_end_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%end_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of end_block not associated.")
    END IF
    arr_size = SHAPE(p%end_block)
    end_block = C_LOC(p%end_block)
  END SUBROUTINE comin_descrdata_get_domain_verts_end_block

  SUBROUTINE comin_descrdata_get_domain_verts_neighbor_blk(jg, neighbor_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_neighbor_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: neighbor_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%neighbor_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of neighbor_blk not associated.")
    END IF
    arr_size = SHAPE(p%neighbor_blk)
    neighbor_blk = C_LOC(p%neighbor_blk)
  END SUBROUTINE comin_descrdata_get_domain_verts_neighbor_blk

  SUBROUTINE comin_descrdata_get_domain_verts_neighbor_idx(jg, neighbor_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_neighbor_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: neighbor_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%neighbor_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of neighbor_idx not associated.")
    END IF
    arr_size = SHAPE(p%neighbor_idx)
    neighbor_idx = C_LOC(p%neighbor_idx)
  END SUBROUTINE comin_descrdata_get_domain_verts_neighbor_idx

  SUBROUTINE comin_descrdata_get_domain_verts_cell_idx(jg, cell_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_cell_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: cell_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%cell_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of cell_idx not associated.")
    END IF
    arr_size = SHAPE(p%cell_idx)
    cell_idx = C_LOC(p%cell_idx)
  END SUBROUTINE comin_descrdata_get_domain_verts_cell_idx

  SUBROUTINE comin_descrdata_get_domain_verts_cell_blk(jg, cell_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_cell_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: cell_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%cell_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of cell_blk not associated.")
    END IF
    arr_size = SHAPE(p%cell_blk)
    cell_blk = C_LOC(p%cell_blk)
  END SUBROUTINE comin_descrdata_get_domain_verts_cell_blk

  SUBROUTINE comin_descrdata_get_domain_verts_edge_idx(jg, edge_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_edge_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: edge_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%edge_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of edge_idx not associated.")
    END IF
    arr_size = SHAPE(p%edge_idx)
    edge_idx = C_LOC(p%edge_idx)
  END SUBROUTINE comin_descrdata_get_domain_verts_edge_idx

  SUBROUTINE comin_descrdata_get_domain_verts_edge_blk(jg, edge_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_edge_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: edge_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ASSOCIATED(p%edge_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of edge_blk not associated.")
    END IF
    arr_size = SHAPE(p%edge_blk)
    edge_blk = C_LOC(p%edge_blk)
  END SUBROUTINE comin_descrdata_get_domain_verts_edge_blk

  SUBROUTINE comin_descrdata_get_domain_verts_vlon(jg, vlon, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_vlon")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vlon
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ALLOCATED(p%vlon)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of vlon not associated.")
    END IF
    arr_size = SHAPE(p%vlon)
    vlon = C_LOC(p%vlon)
  END SUBROUTINE comin_descrdata_get_domain_verts_vlon

  SUBROUTINE comin_descrdata_get_domain_verts_vlat(jg, vlat, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_verts_vlat")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vlat
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_verts), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_verts(jg)
    IF (.NOT. ALLOCATED(p%vlat)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_verts", &
      &  "ERROR: Pointer of vlat not associated.")
    END IF
    arr_size = SHAPE(p%vlat)
    vlat = C_LOC(p%vlat)
  END SUBROUTINE comin_descrdata_get_domain_verts_vlat

  FUNCTION comin_descrdata_get_domain_edges(jg)
    USE iso_c_binding, ONLY: C_INT
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(t_comin_descrdata_domain), POINTER :: p => NULL()
    TYPE(t_comin_descrdata_domain_edges), POINTER :: comin_descrdata_get_domain_edges

    p => comin_descrdata_get_domain(jg)
    comin_descrdata_get_domain_edges => p%edges
  END FUNCTION comin_descrdata_get_domain_edges

  FUNCTION comin_descrdata_get_domain_edges_nedges(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_nedges") &
      &  RESULT(nedges)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nedges
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%nedges)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      & "ERROR: Pointer of nedges not associated.")
    END IF
    nedges  = p%nedges
  END FUNCTION comin_descrdata_get_domain_edges_nedges

  FUNCTION comin_descrdata_get_domain_edges_nedges_global(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_nedges_global") &
      &  RESULT(nedges_global)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nedges_global
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%nedges_global)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      & "ERROR: Pointer of nedges_global not associated.")
    END IF
    nedges_global  = p%nedges_global
  END FUNCTION comin_descrdata_get_domain_edges_nedges_global

  FUNCTION comin_descrdata_get_domain_edges_nblks(jg) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_nblks") &
      &  RESULT(nblks)
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    INTEGER(C_INT)                      :: nblks
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()

    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%nblks)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      & "ERROR: Pointer of nblks not associated.")
    END IF
    nblks  = p%nblks
  END FUNCTION comin_descrdata_get_domain_edges_nblks

  SUBROUTINE comin_descrdata_get_domain_edges_refin_ctrl(jg, refin_ctrl, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_refin_ctrl")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: refin_ctrl
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%refin_ctrl)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of refin_ctrl not associated.")
    END IF
    arr_size = SHAPE(p%refin_ctrl)
    refin_ctrl = C_LOC(p%refin_ctrl)
  END SUBROUTINE comin_descrdata_get_domain_edges_refin_ctrl

  SUBROUTINE comin_descrdata_get_domain_edges_start_index(jg, start_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_start_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%start_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of start_index not associated.")
    END IF
    arr_size = SHAPE(p%start_index)
    start_index = C_LOC(p%start_index)
  END SUBROUTINE comin_descrdata_get_domain_edges_start_index

  SUBROUTINE comin_descrdata_get_domain_edges_end_index(jg, end_index, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_end_index")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_index
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%end_index)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of end_index not associated.")
    END IF
    arr_size = SHAPE(p%end_index)
    end_index = C_LOC(p%end_index)
  END SUBROUTINE comin_descrdata_get_domain_edges_end_index

  SUBROUTINE comin_descrdata_get_domain_edges_start_block(jg, start_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_start_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: start_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%start_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of start_block not associated.")
    END IF
    arr_size = SHAPE(p%start_block)
    start_block = C_LOC(p%start_block)
  END SUBROUTINE comin_descrdata_get_domain_edges_start_block

  SUBROUTINE comin_descrdata_get_domain_edges_end_block(jg, end_block, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_end_block")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: end_block
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%end_block)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of end_block not associated.")
    END IF
    arr_size = SHAPE(p%end_block)
    end_block = C_LOC(p%end_block)
  END SUBROUTINE comin_descrdata_get_domain_edges_end_block

  SUBROUTINE comin_descrdata_get_domain_edges_child_id(jg, child_id, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_child_id")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_id
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%child_id)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of child_id not associated.")
    END IF
    arr_size = SHAPE(p%child_id)
    child_id = C_LOC(p%child_id)
  END SUBROUTINE comin_descrdata_get_domain_edges_child_id

  SUBROUTINE comin_descrdata_get_domain_edges_child_idx(jg, child_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_child_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%child_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of child_idx not associated.")
    END IF
    arr_size = SHAPE(p%child_idx)
    child_idx = C_LOC(p%child_idx)
  END SUBROUTINE comin_descrdata_get_domain_edges_child_idx

  SUBROUTINE comin_descrdata_get_domain_edges_child_blk(jg, child_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_child_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: child_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%child_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of child_blk not associated.")
    END IF
    arr_size = SHAPE(p%child_blk)
    child_blk = C_LOC(p%child_blk)
  END SUBROUTINE comin_descrdata_get_domain_edges_child_blk

  SUBROUTINE comin_descrdata_get_domain_edges_parent_glb_idx(jg, parent_glb_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_parent_glb_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: parent_glb_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%parent_glb_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of parent_glb_idx not associated.")
    END IF
    arr_size = SHAPE(p%parent_glb_idx)
    parent_glb_idx = C_LOC(p%parent_glb_idx)
  END SUBROUTINE comin_descrdata_get_domain_edges_parent_glb_idx

  SUBROUTINE comin_descrdata_get_domain_edges_parent_glb_blk(jg, parent_glb_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_parent_glb_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: parent_glb_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%parent_glb_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of parent_glb_blk not associated.")
    END IF
    arr_size = SHAPE(p%parent_glb_blk)
    parent_glb_blk = C_LOC(p%parent_glb_blk)
  END SUBROUTINE comin_descrdata_get_domain_edges_parent_glb_blk

  SUBROUTINE comin_descrdata_get_domain_edges_cell_idx(jg, cell_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_cell_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: cell_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%cell_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of cell_idx not associated.")
    END IF
    arr_size = SHAPE(p%cell_idx)
    cell_idx = C_LOC(p%cell_idx)
  END SUBROUTINE comin_descrdata_get_domain_edges_cell_idx

  SUBROUTINE comin_descrdata_get_domain_edges_cell_blk(jg, cell_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_cell_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: cell_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%cell_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of cell_blk not associated.")
    END IF
    arr_size = SHAPE(p%cell_blk)
    cell_blk = C_LOC(p%cell_blk)
  END SUBROUTINE comin_descrdata_get_domain_edges_cell_blk

  SUBROUTINE comin_descrdata_get_domain_edges_vertex_idx(jg, vertex_idx, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_vertex_idx")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vertex_idx
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%vertex_idx)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of vertex_idx not associated.")
    END IF
    arr_size = SHAPE(p%vertex_idx)
    vertex_idx = C_LOC(p%vertex_idx)
  END SUBROUTINE comin_descrdata_get_domain_edges_vertex_idx

  SUBROUTINE comin_descrdata_get_domain_edges_vertex_blk(jg, vertex_blk, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_vertex_blk")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: vertex_blk
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(3)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ASSOCIATED(p%vertex_blk)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of vertex_blk not associated.")
    END IF
    arr_size = SHAPE(p%vertex_blk)
    vertex_blk = C_LOC(p%vertex_blk)
  END SUBROUTINE comin_descrdata_get_domain_edges_vertex_blk

  SUBROUTINE comin_descrdata_get_domain_edges_elon(jg, elon, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_elon")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: elon
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ALLOCATED(p%elon)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of elon not associated.")
    END IF
    arr_size = SHAPE(p%elon)
    elon = C_LOC(p%elon)
  END SUBROUTINE comin_descrdata_get_domain_edges_elon

  SUBROUTINE comin_descrdata_get_domain_edges_elat(jg, elat, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_domain_edges_elat")
    INTEGER(C_INT), INTENT(IN), VALUE  :: jg
    TYPE(C_PTR),    INTENT(OUT) :: elat
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(2)
    !
    TYPE(t_comin_descrdata_domain_edges), POINTER :: p => NULL()
    p => comin_descrdata_get_domain_edges(jg)
    IF (.NOT. ALLOCATED(p%elat)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_domain_edges", &
      &  "ERROR: Pointer of elat not associated.")
    END IF
    arr_size = SHAPE(p%elat)
    elat = C_LOC(p%elat)
  END SUBROUTINE comin_descrdata_get_domain_edges_elat
