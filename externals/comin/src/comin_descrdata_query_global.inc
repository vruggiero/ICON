!  @authors 11/2023 :: ICON Community Interface  <comin@icon-model.org>
!
!  SPDX-License-Identifier: BSD-3-Clause
!
!  Please see the file LICENSE in the root of the source tree for this code.
!  Where software is supplied by third parties, it is indicated in the
!  headers of the routines.

! *** DO NOT EDIT MANUALLY!  Generated by python script in utils/. DO NOT EDIT MANUALLY! *** !

  FUNCTION comin_descrdata_get_global_n_dom() &
      &  BIND(C, NAME="comin_descrdata_get_global_n_dom") &
      &  RESULT(n_dom)

    INTEGER(C_INT)                      :: n_dom
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of n_dom not associated.")
    END IF
    n_dom  = p%n_dom
  END FUNCTION comin_descrdata_get_global_n_dom

  FUNCTION comin_descrdata_get_global_max_dom() &
      &  BIND(C, NAME="comin_descrdata_get_global_max_dom") &
      &  RESULT(max_dom)

    INTEGER(C_INT)                      :: max_dom
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of max_dom not associated.")
    END IF
    max_dom  = p%max_dom
  END FUNCTION comin_descrdata_get_global_max_dom

  FUNCTION comin_descrdata_get_global_nproma() &
      &  BIND(C, NAME="comin_descrdata_get_global_nproma") &
      &  RESULT(nproma)

    INTEGER(C_INT)                      :: nproma
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of nproma not associated.")
    END IF
    nproma  = p%nproma
  END FUNCTION comin_descrdata_get_global_nproma

  FUNCTION comin_descrdata_get_global_wp() &
      &  BIND(C, NAME="comin_descrdata_get_global_wp") &
      &  RESULT(wp)

    INTEGER(C_INT)                      :: wp
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of wp not associated.")
    END IF
    wp  = p%wp
  END FUNCTION comin_descrdata_get_global_wp

  FUNCTION comin_descrdata_get_global_min_rlcell_int() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rlcell_int") &
      &  RESULT(min_rlcell_int)

    INTEGER(C_INT)                      :: min_rlcell_int
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rlcell_int not associated.")
    END IF
    min_rlcell_int  = p%min_rlcell_int
  END FUNCTION comin_descrdata_get_global_min_rlcell_int

  FUNCTION comin_descrdata_get_global_min_rlcell() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rlcell") &
      &  RESULT(min_rlcell)

    INTEGER(C_INT)                      :: min_rlcell
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rlcell not associated.")
    END IF
    min_rlcell  = p%min_rlcell
  END FUNCTION comin_descrdata_get_global_min_rlcell

  FUNCTION comin_descrdata_get_global_max_rlcell() &
      &  BIND(C, NAME="comin_descrdata_get_global_max_rlcell") &
      &  RESULT(max_rlcell)

    INTEGER(C_INT)                      :: max_rlcell
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of max_rlcell not associated.")
    END IF
    max_rlcell  = p%max_rlcell
  END FUNCTION comin_descrdata_get_global_max_rlcell

  FUNCTION comin_descrdata_get_global_min_rlvert_int() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rlvert_int") &
      &  RESULT(min_rlvert_int)

    INTEGER(C_INT)                      :: min_rlvert_int
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rlvert_int not associated.")
    END IF
    min_rlvert_int  = p%min_rlvert_int
  END FUNCTION comin_descrdata_get_global_min_rlvert_int

  FUNCTION comin_descrdata_get_global_min_rlvert() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rlvert") &
      &  RESULT(min_rlvert)

    INTEGER(C_INT)                      :: min_rlvert
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rlvert not associated.")
    END IF
    min_rlvert  = p%min_rlvert
  END FUNCTION comin_descrdata_get_global_min_rlvert

  FUNCTION comin_descrdata_get_global_max_rlvert() &
      &  BIND(C, NAME="comin_descrdata_get_global_max_rlvert") &
      &  RESULT(max_rlvert)

    INTEGER(C_INT)                      :: max_rlvert
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of max_rlvert not associated.")
    END IF
    max_rlvert  = p%max_rlvert
  END FUNCTION comin_descrdata_get_global_max_rlvert

  FUNCTION comin_descrdata_get_global_min_rledge_int() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rledge_int") &
      &  RESULT(min_rledge_int)

    INTEGER(C_INT)                      :: min_rledge_int
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rledge_int not associated.")
    END IF
    min_rledge_int  = p%min_rledge_int
  END FUNCTION comin_descrdata_get_global_min_rledge_int

  FUNCTION comin_descrdata_get_global_min_rledge() &
      &  BIND(C, NAME="comin_descrdata_get_global_min_rledge") &
      &  RESULT(min_rledge)

    INTEGER(C_INT)                      :: min_rledge
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of min_rledge not associated.")
    END IF
    min_rledge  = p%min_rledge
  END FUNCTION comin_descrdata_get_global_min_rledge

  FUNCTION comin_descrdata_get_global_max_rledge() &
      &  BIND(C, NAME="comin_descrdata_get_global_max_rledge") &
      &  RESULT(max_rledge)

    INTEGER(C_INT)                      :: max_rledge
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of max_rledge not associated.")
    END IF
    max_rledge  = p%max_rledge
  END FUNCTION comin_descrdata_get_global_max_rledge

  FUNCTION comin_descrdata_get_global_grf_bdywidth_c() &
      &  BIND(C, NAME="comin_descrdata_get_global_grf_bdywidth_c") &
      &  RESULT(grf_bdywidth_c)

    INTEGER(C_INT)                      :: grf_bdywidth_c
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of grf_bdywidth_c not associated.")
    END IF
    grf_bdywidth_c  = p%grf_bdywidth_c
  END FUNCTION comin_descrdata_get_global_grf_bdywidth_c

  FUNCTION comin_descrdata_get_global_grf_bdywidth_e() &
      &  BIND(C, NAME="comin_descrdata_get_global_grf_bdywidth_e") &
      &  RESULT(grf_bdywidth_e)

    INTEGER(C_INT)                      :: grf_bdywidth_e
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of grf_bdywidth_e not associated.")
    END IF
    grf_bdywidth_e  = p%grf_bdywidth_e
  END FUNCTION comin_descrdata_get_global_grf_bdywidth_e

  FUNCTION comin_descrdata_get_global_lrestartrun() &
      &  BIND(C, NAME="comin_descrdata_get_global_lrestartrun") &
      &  RESULT(lrestartrun)

    LOGICAL(C_BOOL)                      :: lrestartrun
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of lrestartrun not associated.")
    END IF
    lrestartrun  = p%lrestartrun
  END FUNCTION comin_descrdata_get_global_lrestartrun

  SUBROUTINE comin_descrdata_get_global_vct_a( vct_a, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_vct_a")

    TYPE(C_PTR),    INTENT(OUT) :: vct_a
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%vct_a)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of vct_a not associated.")
    END IF
    arr_size = SHAPE(p%vct_a)
    vct_a = C_LOC(p%vct_a)
  END SUBROUTINE comin_descrdata_get_global_vct_a

  FUNCTION comin_descrdata_get_global_yac_instance_id() &
      &  BIND(C, NAME="comin_descrdata_get_global_yac_instance_id") &
      &  RESULT(yac_instance_id)

    INTEGER(C_INT)                      :: yac_instance_id
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of yac_instance_id not associated.")
    END IF
    yac_instance_id  = p%yac_instance_id
  END FUNCTION comin_descrdata_get_global_yac_instance_id

  SUBROUTINE comin_descrdata_get_global_host_git_remote_url( host_git_remote_url, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_host_git_remote_url")

    TYPE(C_PTR),    INTENT(OUT) :: host_git_remote_url
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%host_git_remote_url)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of host_git_remote_url not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%host_git_remote_url)
    host_git_remote_url = C_LOC(p%host_git_remote_url)
  END SUBROUTINE comin_descrdata_get_global_host_git_remote_url

  SUBROUTINE comin_descrdata_get_global_host_git_branch( host_git_branch, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_host_git_branch")

    TYPE(C_PTR),    INTENT(OUT) :: host_git_branch
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%host_git_branch)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of host_git_branch not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%host_git_branch)
    host_git_branch = C_LOC(p%host_git_branch)
  END SUBROUTINE comin_descrdata_get_global_host_git_branch

  SUBROUTINE comin_descrdata_get_global_host_git_tag( host_git_tag, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_host_git_tag")

    TYPE(C_PTR),    INTENT(OUT) :: host_git_tag
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%host_git_tag)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of host_git_tag not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%host_git_tag)
    host_git_tag = C_LOC(p%host_git_tag)
  END SUBROUTINE comin_descrdata_get_global_host_git_tag

  SUBROUTINE comin_descrdata_get_global_host_revision( host_revision, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_host_revision")

    TYPE(C_PTR),    INTENT(OUT) :: host_revision
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%host_revision)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of host_revision not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%host_revision)
    host_revision = C_LOC(p%host_revision)
  END SUBROUTINE comin_descrdata_get_global_host_revision

  FUNCTION comin_descrdata_get_global_has_device() &
      &  BIND(C, NAME="comin_descrdata_get_global_has_device") &
      &  RESULT(has_device)

    LOGICAL(C_BOOL)                      :: has_device
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()

    p => comin_descrdata_get_global()
    IF (.NOT. .TRUE.) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      & "ERROR: Pointer of has_device not associated.")
    END IF
    has_device  = p%has_device
  END FUNCTION comin_descrdata_get_global_has_device

  SUBROUTINE comin_descrdata_get_global_device_name( device_name, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_device_name")

    TYPE(C_PTR),    INTENT(OUT) :: device_name
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%device_name)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of device_name not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%device_name)
    device_name = C_LOC(p%device_name)
  END SUBROUTINE comin_descrdata_get_global_device_name

  SUBROUTINE comin_descrdata_get_global_device_vendor( device_vendor, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_device_vendor")

    TYPE(C_PTR),    INTENT(OUT) :: device_vendor
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%device_vendor)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of device_vendor not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%device_vendor)
    device_vendor = C_LOC(p%device_vendor)
  END SUBROUTINE comin_descrdata_get_global_device_vendor

  SUBROUTINE comin_descrdata_get_global_device_driver( device_driver, arr_size) &
      &  BIND(C, NAME="comin_descrdata_get_global_device_driver")

    TYPE(C_PTR),    INTENT(OUT) :: device_driver
    INTEGER(C_INT), INTENT(INOUT) :: arr_size(1)
    !
    TYPE(t_comin_descrdata_global), POINTER :: p => NULL()
    p => comin_descrdata_get_global()
    IF (.NOT. ALLOCATED(p%device_driver)) THEN
      CALL comin_plugin_finish("Message of comin_descrdata_query_global", &
      &  "ERROR: Pointer of device_driver not associated.")
    END IF
    arr_size(1) = LEN_TRIM(p%device_driver)
    device_driver = C_LOC(p%device_driver)
  END SUBROUTINE comin_descrdata_get_global_device_driver
