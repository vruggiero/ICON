
  ! *** DO NOT EDIT MANUALLY! ***
  !     Generated by Python script (comin_build_linked_lists.py) in utils/.
  ! *** DO NOT EDIT MANUALLY! ***

  ! Create a new (orphaned) list item.
  !
  FUNCTION callback_list_newitem(something) RESULT(newitem)
    TYPE(t_comin_callback_element), INTENT(in) :: something
    TYPE(t_callback_list_item), POINTER :: newitem
    ALLOCATE (newitem)
    newitem%item_value = something
    newitem%prevptr => newitem
  END FUNCTION callback_list_newitem

  ! Append an item to a list.
  !
  SUBROUTINE callback_list_append(list, item)
    CLASS(t_callback_list), INTENT(inout), TARGET :: list
    TYPE(t_callback_list_item), TARGET            :: item
    TYPE(t_callback_list_item), POINTER           :: last
    IF (ASSOCIATED(item%upptr)) CALL item%remove()
    item%upptr => list
    IF (ASSOCIATED(list%firstptr)) THEN
      last => list%firstptr%prevptr
      last%nextptr => item
      item%prevptr => last
      list%firstptr%prevptr => item
    ELSE
      list%firstptr => item
      item%prevptr => item
    END IF
  END SUBROUTINE callback_list_append

  ! Delete the contents of a list.
  !
  SUBROUTINE callback_list_delete_list(list)
    CLASS(t_callback_list), INTENT(inout) :: list
    DO
      IF (.NOT.ASSOCIATED(list%firstptr)) EXIT
      CALL callback_list_delete(list%firstptr)
    END DO
  END SUBROUTINE callback_list_delete_list

  ! Return the first element of a list.
  !
  FUNCTION callback_list_first(list) RESULT(first)
    CLASS(t_callback_list), INTENT(in) :: list
    TYPE(t_callback_list_item), POINTER :: first
    first => list%firstptr
  END FUNCTION callback_list_first

  ! Delete an item: removes it from the list and deallocates it.
  !
  SUBROUTINE callback_list_delete(item)
    ! We want to deallocate the dummy argument, so it must be a pointer.
    ! It follows that the procedure cannot be a type-bound procedure.
    TYPE(t_callback_list_item), POINTER :: item
    TYPE(t_callback_list_item), POINTER :: ptr
    ptr => item
    CALL item%remove()
    DEALLOCATE (ptr)
    NULLIFY(item)
  END SUBROUTINE callback_list_delete

  ! Return the list that an item is a member of.  Null if an orphan.
  !
  FUNCTION callback_list_item_list(item) RESULT(list)
    CLASS(t_callback_list_item), INTENT(in) :: item
    TYPE(t_callback_list), POINTER :: list
    list => item%upptr
  END FUNCTION callback_list_item_list

  ! Return the next item in the list.
  !
  FUNCTION callback_list_item_next(item)  RESULT(next)
    CLASS(t_callback_list_item), INTENT(in) :: item
    TYPE(t_callback_list_item), POINTER :: next
    next => item%nextptr
  END FUNCTION callback_list_item_next

  ! Remove an item from a list (but keep it and its value).
  !
  SUBROUTINE callback_list_item_remove(item)
    CLASS(t_callback_list_item), INTENT(inout), TARGET :: item
    TYPE(t_callback_list), POINTER :: list
    list => item%upptr
    IF (ASSOCIATED(list)) THEN
      IF (ASSOCIATED(item%prevptr, item)) THEN
        ! Single item in list.
        NULLIFY(list%firstptr)
      ELSE IF (.NOT.ASSOCIATED(item%nextptr)) THEN
        ! Last item in list.
        list%firstptr%prevptr => item%prevptr
        NULLIFY(item%prevptr%nextptr)
      ELSE IF (ASSOCIATED(list%firstptr, item)) THEN
        ! First item in list.
        list%firstptr => item%nextptr         ! first = next.
        item%prevptr%prevptr => item%nextptr  ! last%prev = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = last.
      ELSE
        item%prevptr%nextptr => item%nextptr  ! last%next = item%next.
        item%nextptr%prevptr => item%prevptr  ! next%prev = item%last.
      end if
      item%prevptr => item
    END IF
    NULLIFY(item%upptr)
  END SUBROUTINE callback_list_item_remove
