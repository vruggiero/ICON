

\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefAttFlt]{cdiDefAttFlt}
\else
cdiDefAttFlt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefAttFlt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER type, INTEGER len, REAL*8 dp)
\end{verbatim}

Define a floating point attribute
\ifpdfoutput{}{(\ref{cdiDefAttFlt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefAttInt]{cdiDefAttInt}
\else
cdiDefAttInt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefAttInt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER type, INTEGER len, INTEGER ip)
\end{verbatim}

Define an integer attribute
\ifpdfoutput{}{(\ref{cdiDefAttInt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefAttTxt]{cdiDefAttTxt}
\else
cdiDefAttTxt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefAttTxt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER len, CHARACTER*(*) tp)
\end{verbatim}

Define a text attribute
\ifpdfoutput{}{(\ref{cdiDefAttTxt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefKeyBytes]{cdiDefKeyBytes}
\else
cdiDefKeyBytes
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefKeyBytes(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                    unsigned CHARACTER*(*) bytes, INTEGER length)
\end{verbatim}

Define a byte array from a key
\ifpdfoutput{}{(\ref{cdiDefKeyBytes})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefKeyFloat]{cdiDefKeyFloat}
\else
cdiDefKeyFloat
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefKeyFloat(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                    REAL*8 value)
\end{verbatim}

Define a floating point value from a key
\ifpdfoutput{}{(\ref{cdiDefKeyFloat})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefKeyInt]{cdiDefKeyInt}
\else
cdiDefKeyInt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefKeyInt(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                  INTEGER value)
\end{verbatim}

Define an integer value from a key
\ifpdfoutput{}{(\ref{cdiDefKeyInt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiDefKeyString]{cdiDefKeyString}
\else
cdiDefKeyString
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiDefKeyString(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                     CHARACTER*(*) string)
\end{verbatim}

Define a string from a key
\ifpdfoutput{}{(\ref{cdiDefKeyString})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqAtt]{cdiInqAtt}
\else
cdiInqAtt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqAtt(INTEGER cdiID, INTEGER varID, INTEGER attnum, 
                               CHARACTER*(*) name, INTEGER typep, INTEGER lenp)
\end{verbatim}

Get information about an attribute
\ifpdfoutput{}{(\ref{cdiInqAtt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqAttFlt]{cdiInqAttFlt}
\else
cdiInqAttFlt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqAttFlt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER mlen, REAL*8 dp)
\end{verbatim}

Get the value(s) of a floating point attribute
\ifpdfoutput{}{(\ref{cdiInqAttFlt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqAttInt]{cdiInqAttInt}
\else
cdiInqAttInt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqAttInt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER mlen, INTEGER ip)
\end{verbatim}

Get the value(s) of an integer attribute
\ifpdfoutput{}{(\ref{cdiInqAttInt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqAttTxt]{cdiInqAttTxt}
\else
cdiInqAttTxt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqAttTxt(INTEGER cdiID, INTEGER varID, CHARACTER*(*) name, 
                                  INTEGER mlen, CHARACTER*(*) tp)
\end{verbatim}

Get the value(s) of a text attribute
\ifpdfoutput{}{(\ref{cdiInqAttTxt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqKeyBytes]{cdiInqKeyBytes}
\else
cdiInqKeyBytes
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqKeyBytes(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                    unsigned CHARACTER*(*) bytes, INTEGER length)
\end{verbatim}

Get a byte array from a key
\ifpdfoutput{}{(\ref{cdiInqKeyBytes})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqKeyFloat]{cdiInqKeyFloat}
\else
cdiInqKeyFloat
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqKeyFloat(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                    REAL*8 value)
\end{verbatim}

Get a floating point value from a key
\ifpdfoutput{}{(\ref{cdiInqKeyFloat})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqKeyInt]{cdiInqKeyInt}
\else
cdiInqKeyInt
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqKeyInt(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                  INTEGER value)
\end{verbatim}

Get an integer value from a key
\ifpdfoutput{}{(\ref{cdiInqKeyInt})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqKeyString]{cdiInqKeyString}
\else
cdiInqKeyString
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqKeyString(INTEGER cdiID, INTEGER varID, INTEGER key, 
                                     CHARACTER*(*) string, INTEGER length)
\end{verbatim}

Get a string from a key
\ifpdfoutput{}{(\ref{cdiInqKeyString})}


\section*{\texttt{ 
\ifpdf
\hyperref[cdiInqNatts]{cdiInqNatts}
\else
cdiInqNatts
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION cdiInqNatts(INTEGER cdiID, INTEGER varID, INTEGER nattsp)
\end{verbatim}

Get number of attributes
\ifpdfoutput{}{(\ref{cdiInqNatts})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridCreate]{gridCreate}
\else
gridCreate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridCreate(INTEGER gridtype, INTEGER size)
\end{verbatim}

Create a horizontal Grid
\ifpdfoutput{}{(\ref{gridCreate})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefNP]{gridDefNP}
\else
gridDefNP
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefNP(INTEGER gridID, INTEGER np)
\end{verbatim}

Define the number of parallels between a pole and the equator
\ifpdfoutput{}{(\ref{gridDefNP})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefXbounds]{gridDefXbounds}
\else
gridDefXbounds
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefXbounds(INTEGER gridID, REAL*8 xbounds)
\end{verbatim}

Define the bounds of a X-axis
\ifpdfoutput{}{(\ref{gridDefXbounds})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefXsize]{gridDefXsize}
\else
gridDefXsize
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefXsize(INTEGER gridID, INTEGER xsize)
\end{verbatim}

Define the number of values of a X-axis
\ifpdfoutput{}{(\ref{gridDefXsize})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefXvals]{gridDefXvals}
\else
gridDefXvals
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefXvals(INTEGER gridID, REAL*8 xvals)
\end{verbatim}

Define the values of a X-axis
\ifpdfoutput{}{(\ref{gridDefXvals})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefYbounds]{gridDefYbounds}
\else
gridDefYbounds
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefYbounds(INTEGER gridID, REAL*8 ybounds)
\end{verbatim}

Define the bounds of a Y-axis
\ifpdfoutput{}{(\ref{gridDefYbounds})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefYsize]{gridDefYsize}
\else
gridDefYsize
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefYsize(INTEGER gridID, INTEGER ysize)
\end{verbatim}

Define the number of values of a Y-axis
\ifpdfoutput{}{(\ref{gridDefYsize})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDefYvals]{gridDefYvals}
\else
gridDefYvals
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDefYvals(INTEGER gridID, REAL*8 yvals)
\end{verbatim}

Define the values of a Y-axis
\ifpdfoutput{}{(\ref{gridDefYvals})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDestroy]{gridDestroy}
\else
gridDestroy
\fi
}}
\begin{verbatim}
    SUBROUTINE gridDestroy(INTEGER gridID)
\end{verbatim}

Destroy a horizontal Grid
\ifpdfoutput{}{(\ref{gridDestroy})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridDuplicate]{gridDuplicate}
\else
gridDuplicate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridDuplicate(INTEGER gridID)
\end{verbatim}

Duplicate a horizontal Grid
\ifpdfoutput{}{(\ref{gridDuplicate})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqNP]{gridInqNP}
\else
gridInqNP
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqNP(INTEGER gridID)
\end{verbatim}

Get the number of parallels between a pole and the equator
\ifpdfoutput{}{(\ref{gridInqNP})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqSize]{gridInqSize}
\else
gridInqSize
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqSize(INTEGER gridID)
\end{verbatim}

Get the size of a Grid
\ifpdfoutput{}{(\ref{gridInqSize})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqType]{gridInqType}
\else
gridInqType
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqType(INTEGER gridID)
\end{verbatim}

Get the type of a Grid
\ifpdfoutput{}{(\ref{gridInqType})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqXbounds]{gridInqXbounds}
\else
gridInqXbounds
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqXbounds(INTEGER gridID, REAL*8 xbounds)
\end{verbatim}

Get the bounds of a X-axis
\ifpdfoutput{}{(\ref{gridInqXbounds})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqXsize]{gridInqXsize}
\else
gridInqXsize
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqXsize(INTEGER gridID)
\end{verbatim}

Get the number of values of a X-axis
\ifpdfoutput{}{(\ref{gridInqXsize})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqXvals]{gridInqXvals}
\else
gridInqXvals
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqXvals(INTEGER gridID, REAL*8 xvals)
\end{verbatim}

Get all values of a X-axis
\ifpdfoutput{}{(\ref{gridInqXvals})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqYbounds]{gridInqYbounds}
\else
gridInqYbounds
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqYbounds(INTEGER gridID, REAL*8 ybounds)
\end{verbatim}

Get the bounds of a Y-axis
\ifpdfoutput{}{(\ref{gridInqYbounds})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqYsize]{gridInqYsize}
\else
gridInqYsize
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqYsize(INTEGER gridID)
\end{verbatim}

Get the number of values of a Y-axis
\ifpdfoutput{}{(\ref{gridInqYsize})}


\section*{\texttt{ 
\ifpdf
\hyperref[gridInqYvals]{gridInqYvals}
\else
gridInqYvals
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION gridInqYvals(INTEGER gridID, REAL*8 yvals)
\end{verbatim}

Get all values of a Y-axis
\ifpdfoutput{}{(\ref{gridInqYvals})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamClose]{streamClose}
\else
streamClose
\fi
}}
\begin{verbatim}
    SUBROUTINE streamClose(INTEGER streamID)
\end{verbatim}

Close an open dataset
\ifpdfoutput{}{(\ref{streamClose})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamDefByteorder]{streamDefByteorder}
\else
streamDefByteorder
\fi
}}
\begin{verbatim}
    SUBROUTINE streamDefByteorder(INTEGER streamID, INTEGER byteorder)
\end{verbatim}

Define the byte order
\ifpdfoutput{}{(\ref{streamDefByteorder})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamDefRecord]{streamDefRecord}
\else
streamDefRecord
\fi
}}
\begin{verbatim}
    SUBROUTINE streamDefRecord(INTEGER streamID, INTEGER varID, INTEGER levelID)
\end{verbatim}

Define the next record
\ifpdfoutput{}{(\ref{streamDefRecord})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamDefTimestep]{streamDefTimestep}
\else
streamDefTimestep
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamDefTimestep(INTEGER streamID, INTEGER tsID)
\end{verbatim}

Define a timestep
\ifpdfoutput{}{(\ref{streamDefTimestep})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamDefVlist]{streamDefVlist}
\else
streamDefVlist
\fi
}}
\begin{verbatim}
    SUBROUTINE streamDefVlist(INTEGER streamID, INTEGER vlistID)
\end{verbatim}

Define the variable list
\ifpdfoutput{}{(\ref{streamDefVlist})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamInqByteorder]{streamInqByteorder}
\else
streamInqByteorder
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamInqByteorder(INTEGER streamID)
\end{verbatim}

Get the byte order
\ifpdfoutput{}{(\ref{streamInqByteorder})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamInqFiletype]{streamInqFiletype}
\else
streamInqFiletype
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamInqFiletype(INTEGER streamID)
\end{verbatim}

Get the filetype
\ifpdfoutput{}{(\ref{streamInqFiletype})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamInqTimestep]{streamInqTimestep}
\else
streamInqTimestep
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamInqTimestep(INTEGER streamID, INTEGER tsID)
\end{verbatim}

Get timestep information
\ifpdfoutput{}{(\ref{streamInqTimestep})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamInqVlist]{streamInqVlist}
\else
streamInqVlist
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamInqVlist(INTEGER streamID)
\end{verbatim}

Get the variable list
\ifpdfoutput{}{(\ref{streamInqVlist})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamOpenRead]{streamOpenRead}
\else
streamOpenRead
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamOpenRead(CHARACTER*(*) path)
\end{verbatim}

Open a dataset for reading
\ifpdfoutput{}{(\ref{streamOpenRead})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamOpenWrite]{streamOpenWrite}
\else
streamOpenWrite
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION streamOpenWrite(CHARACTER*(*) path, INTEGER filetype)
\end{verbatim}

Create a new dataset
\ifpdfoutput{}{(\ref{streamOpenWrite})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamReadVar]{streamReadVar}
\else
streamReadVar
\fi
}}
\begin{verbatim}
    SUBROUTINE streamReadVar(INTEGER streamID, INTEGER varID, REAL*8 data, 
                             INTEGER numMissVals)
\end{verbatim}

Read a variable
\ifpdfoutput{}{(\ref{streamReadVar})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamReadVarF]{streamReadVarF}
\else
streamReadVarF
\fi
}}
\begin{verbatim}
    SUBROUTINE streamReadVar(INTEGER streamID, INTEGER varID, REAL*4 data, 
                             INTEGER numMissVals)
\end{verbatim}

Read a variable
\ifpdfoutput{}{(\ref{streamReadVarF})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamReadVarSlice]{streamReadVarSlice}
\else
streamReadVarSlice
\fi
}}
\begin{verbatim}
    SUBROUTINE streamReadVarSlice(INTEGER streamID, INTEGER varID, INTEGER levelID, 
                                  REAL*8 data, INTEGER numMissVals)
\end{verbatim}

Read a horizontal slice of a variable
\ifpdfoutput{}{(\ref{streamReadVarSlice})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamReadVarSliceF]{streamReadVarSliceF}
\else
streamReadVarSliceF
\fi
}}
\begin{verbatim}
    SUBROUTINE streamReadVarSliceF(INTEGER streamID, INTEGER varID, INTEGER levelID, 
                                   REAL*4 data, INTEGER numMissVals)
\end{verbatim}

Read a horizontal slice of a variable
\ifpdfoutput{}{(\ref{streamReadVarSliceF})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamWriteVar]{streamWriteVar}
\else
streamWriteVar
\fi
}}
\begin{verbatim}
    SUBROUTINE streamWriteVar(INTEGER streamID, INTEGER varID, REAL*8 data, 
                              INTEGER numMissVals)
\end{verbatim}

Write a variable
\ifpdfoutput{}{(\ref{streamWriteVar})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamWriteVarF]{streamWriteVarF}
\else
streamWriteVarF
\fi
}}
\begin{verbatim}
    SUBROUTINE streamWriteVarF(INTEGER streamID, INTEGER varID, REAL*4 data, 
                               INTEGER numMissVals)
\end{verbatim}

Write a variable
\ifpdfoutput{}{(\ref{streamWriteVarF})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamWriteVarSlice]{streamWriteVarSlice}
\else
streamWriteVarSlice
\fi
}}
\begin{verbatim}
    SUBROUTINE streamWriteVarSlice(INTEGER streamID, INTEGER varID, INTEGER levelID, 
                                   REAL*8 data, INTEGER numMissVals)
\end{verbatim}

Write a horizontal slice of a variable
\ifpdfoutput{}{(\ref{streamWriteVarSlice})}


\section*{\texttt{ 
\ifpdf
\hyperref[streamWriteVarSliceF]{streamWriteVarSliceF}
\else
streamWriteVarSliceF
\fi
}}
\begin{verbatim}
    SUBROUTINE streamWriteVarSliceF(INTEGER streamID, INTEGER varID, INTEGER levelID, 
                                    REAL*4 data, INTEGER numMissVals)
\end{verbatim}

Write a horizontal slice of a variable
\ifpdfoutput{}{(\ref{streamWriteVarSliceF})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisCreate]{taxisCreate}
\else
taxisCreate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisCreate(INTEGER taxistype)
\end{verbatim}

Create a Time axis
\ifpdfoutput{}{(\ref{taxisCreate})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDefCalendar]{taxisDefCalendar}
\else
taxisDefCalendar
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDefCalendar(INTEGER taxisID, INTEGER calendar)
\end{verbatim}

Define the calendar
\ifpdfoutput{}{(\ref{taxisDefCalendar})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDefRdate]{taxisDefRdate}
\else
taxisDefRdate
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDefRdate(INTEGER taxisID, INTEGER rdate)
\end{verbatim}

Define the reference date
\ifpdfoutput{}{(\ref{taxisDefRdate})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDefRtime]{taxisDefRtime}
\else
taxisDefRtime
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDefRtime(INTEGER taxisID, INTEGER rtime)
\end{verbatim}

Define the reference time
\ifpdfoutput{}{(\ref{taxisDefRtime})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDefVdate]{taxisDefVdate}
\else
taxisDefVdate
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDefVdate(INTEGER taxisID, INTEGER vdate)
\end{verbatim}

Define the verification date
\ifpdfoutput{}{(\ref{taxisDefVdate})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDefVtime]{taxisDefVtime}
\else
taxisDefVtime
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDefVtime(INTEGER taxisID, INTEGER vtime)
\end{verbatim}

Define the verification time
\ifpdfoutput{}{(\ref{taxisDefVtime})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisDestroy]{taxisDestroy}
\else
taxisDestroy
\fi
}}
\begin{verbatim}
    SUBROUTINE taxisDestroy(INTEGER taxisID)
\end{verbatim}

Destroy a Time axis
\ifpdfoutput{}{(\ref{taxisDestroy})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisInqCalendar]{taxisInqCalendar}
\else
taxisInqCalendar
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisInqCalendar(INTEGER taxisID)
\end{verbatim}

Get the calendar
\ifpdfoutput{}{(\ref{taxisInqCalendar})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisInqRdate]{taxisInqRdate}
\else
taxisInqRdate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisInqRdate(INTEGER taxisID)
\end{verbatim}

Get the reference date
\ifpdfoutput{}{(\ref{taxisInqRdate})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisInqRtime]{taxisInqRtime}
\else
taxisInqRtime
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisInqRtime(INTEGER taxisID)
\end{verbatim}

Get the reference time
\ifpdfoutput{}{(\ref{taxisInqRtime})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisInqVdate]{taxisInqVdate}
\else
taxisInqVdate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisInqVdate(INTEGER taxisID)
\end{verbatim}

Get the verification date
\ifpdfoutput{}{(\ref{taxisInqVdate})}


\section*{\texttt{ 
\ifpdf
\hyperref[taxisInqVtime]{taxisInqVtime}
\else
taxisInqVtime
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION taxisInqVtime(INTEGER taxisID)
\end{verbatim}

Get the verification time
\ifpdfoutput{}{(\ref{taxisInqVtime})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistCat]{vlistCat}
\else
vlistCat
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistCat(INTEGER vlistID2, INTEGER vlistID1)
\end{verbatim}

Concatenate two variable lists
\ifpdfoutput{}{(\ref{vlistCat})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistCopy]{vlistCopy}
\else
vlistCopy
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistCopy(INTEGER vlistID2, INTEGER vlistID1)
\end{verbatim}

Copy a variable list
\ifpdfoutput{}{(\ref{vlistCopy})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistCopyFlag]{vlistCopyFlag}
\else
vlistCopyFlag
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistCopyFlag(INTEGER vlistID2, INTEGER vlistID1)
\end{verbatim}

Copy some entries of a variable list
\ifpdfoutput{}{(\ref{vlistCopyFlag})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistCreate]{vlistCreate}
\else
vlistCreate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistCreate()
\end{verbatim}

Create a variable list
\ifpdfoutput{}{(\ref{vlistCreate})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDefTaxis]{vlistDefTaxis}
\else
vlistDefTaxis
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistDefTaxis(INTEGER vlistID, INTEGER taxisID)
\end{verbatim}

Define the time axis
\ifpdfoutput{}{(\ref{vlistDefTaxis})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDefVar]{vlistDefVar}
\else
vlistDefVar
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistDefVar(INTEGER vlistID, INTEGER gridID, INTEGER zaxisID, 
                                 INTEGER timetype)
\end{verbatim}

Define a Variable
\ifpdfoutput{}{(\ref{vlistDefVar})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDefVarCode]{vlistDefVarCode}
\else
vlistDefVarCode
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistDefVarCode(INTEGER vlistID, INTEGER varID, INTEGER code)
\end{verbatim}

Define the code number of a Variable
\ifpdfoutput{}{(\ref{vlistDefVarCode})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDefVarDatatype]{vlistDefVarDatatype}
\else
vlistDefVarDatatype
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistDefVarDatatype(INTEGER vlistID, INTEGER varID, INTEGER datatype)
\end{verbatim}

Define the data type of a Variable
\ifpdfoutput{}{(\ref{vlistDefVarDatatype})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDefVarMissval]{vlistDefVarMissval}
\else
vlistDefVarMissval
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistDefVarMissval(INTEGER vlistID, INTEGER varID, REAL*8 missval)
\end{verbatim}

Define the missing value of a Variable
\ifpdfoutput{}{(\ref{vlistDefVarMissval})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDestroy]{vlistDestroy}
\else
vlistDestroy
\fi
}}
\begin{verbatim}
    SUBROUTINE vlistDestroy(INTEGER vlistID)
\end{verbatim}

Destroy a variable list
\ifpdfoutput{}{(\ref{vlistDestroy})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistDuplicate]{vlistDuplicate}
\else
vlistDuplicate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistDuplicate(INTEGER vlistID)
\end{verbatim}

Duplicate a variable list
\ifpdfoutput{}{(\ref{vlistDuplicate})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqTaxis]{vlistInqTaxis}
\else
vlistInqTaxis
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqTaxis(INTEGER vlistID)
\end{verbatim}

Get the time axis
\ifpdfoutput{}{(\ref{vlistInqTaxis})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarCode]{vlistInqVarCode}
\else
vlistInqVarCode
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqVarCode(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the Code number of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarCode})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarDatatype]{vlistInqVarDatatype}
\else
vlistInqVarDatatype
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqVarDatatype(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the data type of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarDatatype})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarGrid]{vlistInqVarGrid}
\else
vlistInqVarGrid
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqVarGrid(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the Grid ID of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarGrid})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarMissval]{vlistInqVarMissval}
\else
vlistInqVarMissval
\fi
}}
\begin{verbatim}
    REAL*8 FUNCTION vlistInqVarMissval(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the missing value of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarMissval})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarTsteptype]{vlistInqVarTsteptype}
\else
vlistInqVarTsteptype
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqVarTsteptype(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the timestep type of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarTsteptype})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistInqVarZaxis]{vlistInqVarZaxis}
\else
vlistInqVarZaxis
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistInqVarZaxis(INTEGER vlistID, INTEGER varID)
\end{verbatim}

Get the Zaxis ID of a Variable
\ifpdfoutput{}{(\ref{vlistInqVarZaxis})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistNgrids]{vlistNgrids}
\else
vlistNgrids
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistNgrids(INTEGER vlistID)
\end{verbatim}

Number of grids in a variable list
\ifpdfoutput{}{(\ref{vlistNgrids})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistNvars]{vlistNvars}
\else
vlistNvars
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistNvars(INTEGER vlistID)
\end{verbatim}

Number of variables in a variable list
\ifpdfoutput{}{(\ref{vlistNvars})}


\section*{\texttt{ 
\ifpdf
\hyperref[vlistNzaxis]{vlistNzaxis}
\else
vlistNzaxis
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION vlistNzaxis(INTEGER vlistID)
\end{verbatim}

Number of zaxis in a variable list
\ifpdfoutput{}{(\ref{vlistNzaxis})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisCreate]{zaxisCreate}
\else
zaxisCreate
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION zaxisCreate(INTEGER zaxistype, INTEGER size)
\end{verbatim}

Create a vertical Z-axis
\ifpdfoutput{}{(\ref{zaxisCreate})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisDefLevels]{zaxisDefLevels}
\else
zaxisDefLevels
\fi
}}
\begin{verbatim}
    SUBROUTINE zaxisDefLevels(INTEGER zaxisID, REAL*8 levels)
\end{verbatim}

Define the levels of a Z-axis
\ifpdfoutput{}{(\ref{zaxisDefLevels})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisDestroy]{zaxisDestroy}
\else
zaxisDestroy
\fi
}}
\begin{verbatim}
    SUBROUTINE zaxisDestroy(INTEGER zaxisID)
\end{verbatim}

Destroy a vertical Z-axis
\ifpdfoutput{}{(\ref{zaxisDestroy})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisInqLevel]{zaxisInqLevel}
\else
zaxisInqLevel
\fi
}}
\begin{verbatim}
    REAL*8 FUNCTION zaxisInqLevel(INTEGER zaxisID, INTEGER levelID)
\end{verbatim}

Get one level of a Z-axis
\ifpdfoutput{}{(\ref{zaxisInqLevel})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisInqLevels]{zaxisInqLevels}
\else
zaxisInqLevels
\fi
}}
\begin{verbatim}
    SUBROUTINE zaxisInqLevels(INTEGER zaxisID, REAL*8 levels)
\end{verbatim}

Get all levels of a Z-axis
\ifpdfoutput{}{(\ref{zaxisInqLevels})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisInqSize]{zaxisInqSize}
\else
zaxisInqSize
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION zaxisInqSize(INTEGER zaxisID)
\end{verbatim}

Get the size of a Z-axis
\ifpdfoutput{}{(\ref{zaxisInqSize})}


\section*{\texttt{ 
\ifpdf
\hyperref[zaxisInqType]{zaxisInqType}
\else
zaxisInqType
\fi
}}
\begin{verbatim}
    INTEGER FUNCTION zaxisInqType(INTEGER zaxisID)
\end{verbatim}

Get the type of a Z-axis
\ifpdfoutput{}{(\ref{zaxisInqType})}
